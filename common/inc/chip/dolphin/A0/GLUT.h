//////
/// don't edit! auto-generated by docc: GLUT.h
////////////////////////////////////////////////////////////
#ifndef GLUT_h
#define GLUT_h (){}


#include "ctypes.h"

#pragma pack(1)
#ifdef __cplusplus
  extern "C" {
#endif

#ifndef _DOCC_H_BITOPS_
#define _DOCC_H_BITOPS_ (){}

    #define _bSETMASK_(b)                                      ((b)<32 ? (1<<((b)&31)) : 0)
    #define _NSETMASK_(msb,lsb)                                (_bSETMASK_((msb)+1)-_bSETMASK_(lsb))
    #define _bCLRMASK_(b)                                      (~_bSETMASK_(b))
    #define _NCLRMASK_(msb,lsb)                                (~_NSETMASK_(msb,lsb))
    #define _BFGET_(r,msb,lsb)                                 (_NSETMASK_((msb)-(lsb),0)&((r)>>(lsb)))
    #define _BFSET_(r,msb,lsb,v)                               do{ (r)&=_NCLRMASK_(msb,lsb); (r)|=_NSETMASK_(msb,lsb)&((v)<<(lsb)); }while(0)

#endif



//////
/// 
/// $INTERFACE glut32                                   (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 entry                (RW)
///               %unsigned 32 DATA                      
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:      32b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_glut32
#define h_glut32 (){}

    #define     RA_glut32_entry                                0x0000

    #define     BA_glut32_entry_DATA                           0x0000
    #define     B16glut32_entry_DATA                           0x0000
    #define   LSb32glut32_entry_DATA                              0
    #define   LSb16glut32_entry_DATA                              0
    #define       bglut32_entry_DATA                           32
    #define   MSK32glut32_entry_DATA                              0xFFFFFFFF
    ///////////////////////////////////////////////////////////

    typedef struct SIE_glut32 {
    ///////////////////////////////////////////////////////////
    #define   GET32glut32_entry_DATA(r32)                      _BFGET_(r32,31, 0)
    #define   SET32glut32_entry_DATA(r32,v)                    _BFSET_(r32,31, 0,v)

    #define     w32glut32_entry                                {\
            UNSG32 uentry_DATA                                 : 32;\
          }
    union { UNSG32 u32glut32_entry;
            struct w32glut32_entry;
          };
    ///////////////////////////////////////////////////////////
    } SIE_glut32;

    typedef union  T32glut32_entry
          { UNSG32 u32;
            struct w32glut32_entry;
                 } T32glut32_entry;
    ///////////////////////////////////////////////////////////

    typedef union  Tglut32_entry
          { UNSG32 u32[1];
            struct {
            struct w32glut32_entry;
                   };
                 } Tglut32_entry;

    ///////////////////////////////////////////////////////////
     SIGN32 glut32_drvrd(SIE_glut32 *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 glut32_drvwr(SIE_glut32 *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void glut32_reset(SIE_glut32 *p);
     SIGN32 glut32_cmp  (SIE_glut32 *p, SIE_glut32 *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define glut32_check(p,pie,pfx,hLOG) glut32_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define glut32_print(p,    pfx,hLOG) glut32_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: glut32
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE LUT2D                                    (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [289]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:    1156B, bits:    9248b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_LUT2D
#define h_LUT2D (){}

    #define     RA_LUT2D_dummy                                 0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_LUT2D {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[289];
    ///////////////////////////////////////////////////////////
    } SIE_LUT2D;

    ///////////////////////////////////////////////////////////
     SIGN32 LUT2D_drvrd(SIE_LUT2D *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 LUT2D_drvwr(SIE_LUT2D *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void LUT2D_reset(SIE_LUT2D *p);
     SIGN32 LUT2D_cmp  (SIE_LUT2D *p, SIE_LUT2D *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define LUT2D_check(p,pie,pfx,hLOG) LUT2D_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define LUT2D_print(p,    pfx,hLOG) LUT2D_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: LUT2D
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE INLUT                                    (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [387]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:    1548B, bits:   12384b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_INLUT
#define h_INLUT (){}

    #define     RA_INLUT_dummy                                 0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_INLUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[387];
    ///////////////////////////////////////////////////////////
    } SIE_INLUT;

    ///////////////////////////////////////////////////////////
     SIGN32 INLUT_drvrd(SIE_INLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 INLUT_drvwr(SIE_INLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void INLUT_reset(SIE_INLUT *p);
     SIGN32 INLUT_cmp  (SIE_INLUT *p, SIE_INLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define INLUT_check(p,pie,pfx,hLOG) INLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define INLUT_print(p,    pfx,hLOG) INLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: INLUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE OUTLUT                                   (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [387]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:    1548B, bits:   12384b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_OUTLUT
#define h_OUTLUT (){}

    #define     RA_OUTLUT_dummy                                0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_OUTLUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[387];
    ///////////////////////////////////////////////////////////
    } SIE_OUTLUT;

    ///////////////////////////////////////////////////////////
     SIGN32 OUTLUT_drvrd(SIE_OUTLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 OUTLUT_drvwr(SIE_OUTLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void OUTLUT_reset(SIE_OUTLUT *p);
     SIGN32 OUTLUT_cmp  (SIE_OUTLUT *p, SIE_OUTLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define OUTLUT_check(p,pie,pfx,hLOG) OUTLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define OUTLUT_print(p,    pfx,hLOG) OUTLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: OUTLUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE CLUT                                     (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [128]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:     512B, bits:    4096b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_CLUT
#define h_CLUT (){}

    #define     RA_CLUT_dummy                                  0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_CLUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[128];
    ///////////////////////////////////////////////////////////
    } SIE_CLUT;

    ///////////////////////////////////////////////////////////
     SIGN32 CLUT_drvrd(SIE_CLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 CLUT_drvwr(SIE_CLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void CLUT_reset(SIE_CLUT *p);
     SIGN32 CLUT_cmp  (SIE_CLUT *p, SIE_CLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define CLUT_check(p,pie,pfx,hLOG) CLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define CLUT_print(p,    pfx,hLOG) CLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: CLUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE DLUT                                     (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [384]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:    1536B, bits:   12288b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_DLUT
#define h_DLUT (){}

    #define     RA_DLUT_dummy                                  0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_DLUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[384];
    ///////////////////////////////////////////////////////////
    } SIE_DLUT;

    ///////////////////////////////////////////////////////////
     SIGN32 DLUT_drvrd(SIE_DLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 DLUT_drvwr(SIE_DLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void DLUT_reset(SIE_DLUT *p);
     SIGN32 DLUT_cmp  (SIE_DLUT *p, SIE_DLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define DLUT_check(p,pie,pfx,hLOG) DLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define DLUT_print(p,    pfx,hLOG) DLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: DLUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE ILUT                                     (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [128]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:     512B, bits:    4096b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_ILUT
#define h_ILUT (){}

    #define     RA_ILUT_dummy                                  0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_ILUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[128];
    ///////////////////////////////////////////////////////////
    } SIE_ILUT;

    ///////////////////////////////////////////////////////////
     SIGN32 ILUT_drvrd(SIE_ILUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 ILUT_drvwr(SIE_ILUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void ILUT_reset(SIE_ILUT *p);
     SIGN32 ILUT_cmp  (SIE_ILUT *p, SIE_ILUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define ILUT_check(p,pie,pfx,hLOG) ILUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define ILUT_print(p,    pfx,hLOG) ILUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: ILUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE PLUT                                     (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [128]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:     512B, bits:    4096b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_PLUT
#define h_PLUT (){}

    #define     RA_PLUT_dummy                                  0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_PLUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[128];
    ///////////////////////////////////////////////////////////
    } SIE_PLUT;

    ///////////////////////////////////////////////////////////
     SIGN32 PLUT_drvrd(SIE_PLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 PLUT_drvwr(SIE_PLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void PLUT_reset(SIE_PLUT *p);
     SIGN32 PLUT_cmp  (SIE_PLUT *p, SIE_PLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define PLUT_check(p,pie,pfx,hLOG) PLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define PLUT_print(p,    pfx,hLOG) PLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: PLUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE SLUT                                     (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy                
///               $glut32              dummy             REG     [128]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:     512B, bits:    4096b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_SLUT
#define h_SLUT (){}

    #define     RA_SLUT_dummy                                  0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_SLUT {
    ///////////////////////////////////////////////////////////
              SIE_glut32                                       ie_dummy[128];
    ///////////////////////////////////////////////////////////
    } SIE_SLUT;

    ///////////////////////////////////////////////////////////
     SIGN32 SLUT_drvrd(SIE_SLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 SLUT_drvwr(SIE_SLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void SLUT_reset(SIE_SLUT *p);
     SIGN32 SLUT_cmp  (SIE_SLUT *p, SIE_SLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define SLUT_check(p,pie,pfx,hLOG) SLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define SLUT_print(p,    pfx,hLOG) SLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: SLUT
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE GLUT                    biu              (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 CTRL                 (P)
///               %unsigned 1  IP_Sel                    0x0
///                                    ###
///                                    * 0: Select to connect to GDCM IP
///                                    * 1: Select to connect to GITM IP
///                                    ###
///               %%        31         # Stuffing bits...
///     @ 0x00004 RAM                  (P)
///               %unsigned 1  rw_en                     0x0
///                                    ###
///                                    * Set 1 to Enable RAM load/Read(RAM access),
///                                    * Turn off (0)once Read/Write memory access is complete.
///                                    ###
///               %unsigned 3  ram_sel                   0x0
///                                    ###
///                                    * 0: Select to load/read Lsh 2D LUT Ram
///                                    * 1: Select to load/read Input EOTF LUT Ram
///                                    * 2: Select to load/read Output OETF LUT Ram
///                                    * 3: Select to load/read CLUT Ram
///                                    * 4: Select to load/read DLUT Ram
///                                    * 5: Select to load/read ILUT Ram
///                                    * 6: Select to load/read PLUT Ram
///                                    * 7: Select to load/read SLUT Ram
///                                    ###
///               %%        28         # Stuffing bits...
///     @ 0x00008                      (W-)
///     #         # Stuffing bytes...
///               %% 16320
///     @ 0x00800                      (P)
///     # 0x00800 LUT2D                
///               $LUT2D               LUT2D             MEM          
///                                    ###
///                                    * LUT can only be programmed during Vertical Blank period.
///                                    * YUV color remapping (LSH to YUV mapping) LUT, 289 Memory locations with 30 bit each.
///                                    * LUTs are stored in 4 Segments
///                                    * Segment0, 81 locations= ((addr[8:0]>=0) & (addr[8:0]<81))
///                                    * Segment1, 72 locations= ((addr[8:0]>=81) & (addr[8:0]<153))
///                                    * Segment2, 72 locations= ((addr[8:0]>=153) & (addr[8:0]<225))
///                                    * Segment3, 64 locations= ((addr[8:0]>=225) & (addr[8:0]<289))
///                                    * ELUT even in GITM shares Segment0 of SRAM.
///                                    * ELUT odd in GITM shares Segment1 of SRAM.
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x01000                      (P)
///     # 0x01000 INLUT                
///               $INLUT               INLUT             MEM          
///                                    ###
///                                    * LUT can only be programmed during Vertical Blank period.
///                                    * This is EOTF Input LUT, 384 Memory locations with 24 bit each. Data format is {lut_val_Odd[11:0], lut_val_Even[11:0]}.
///                                    * LUTs are stored in 3 Segments
///                                    * Segment0 is for R InLut, 128 locations= ((addr[8:0]>=0) & (addr[8:0]<128))
///                                    * Segment1 is for G InLut, 128 locations= ((addr[8:0]>=128) & (addr[8:0]<256))
///                                    * Segment2 is for B InLut , 128 locations= ((addr[8:0]>=256) & (addr[8:0]<384))
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x01800                      (P)
///     # 0x01800 OUTLUT               
///               $OUTLUT              OUTLUT            MEM          
///                                    ###
///                                    * LUT can only be programmed during Vertical Blank period.
///                                    * This is OETF Output LUT, 384 Memory locations with 24 bit each. Data format is {lut_val_Odd[11:0], lut_val_Even[11:0]}.
///                                    * LUTs are stored in 3 Segments
///                                    * Segment0 is for R OutLut, 128 locations= ((addr[8:0]>=0) & (addr[8:0]<128))
///                                    * Segment1 is for G OutLut, 128 locations= ((addr[8:0]>=128) & (addr[8:0]<256))
///                                    * Segment2 is for B OutLut, 128 locations= ((addr[8:0]>=256) & (addr[8:0]<384))
///                                    * PQLUT in GITM shares these group of SRAMs.
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x02000                      (P)
///     # 0x02000 CLUT                 
///               $CLUT                CLUT              MEM          
///                                    ###
///                                    * CLUT can only be programmed during Vertical Blank period.
///                                    * The CLUT has 32 Memory locations with 22 bit each. Its data format is {lut_val_Odd[10:0], lut_val_Even[10:0]}.
///                                    * LUTs are stored in One Segments
///                                    * Segment0, 32 locations= ((addr[7:0]>=0) & (addr[7:0]<32))
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x02200                      (W-)
///     #         # Stuffing bytes...
///               %% 12288
///     @ 0x02800                      (P)
///     # 0x02800 DLUT                 
///               $DLUT                DLUT              MEM          
///                                    ###
///                                    * DLUT can only be programmed during Vertical Blank period.
///                                    * The DLUT has 96 Memory locations with 24 bit each. Its data format is {lut_val_Odd[11:0], lut_val_Even[11:0]}.
///                                    * LUTs are stored in 3 Segments
///                                    * Segment0, 32 locations= ((addr[7:0]>=0) & (addr[7:0]<32))
///                                    * Segment1, 32 locations= ((addr[7:0]>=32) & (addr[7:0]<64))
///                                    * Segment2, 32 locations= ((addr[7:0]>=64) & (addr[7:0]<96))
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x03000                      (P)
///     # 0x03000 ILUT                 
///               $ILUT                ILUT              MEM          
///                                    ###
///                                    * ILUT can only be programmed during Vertical Blank period.
///                                    * The ILUT has 32 Memory locations with 16 bit each. Its data format is {lut_val_Odd[7:0], lut_val_Even[7:0]}.
///                                    * LUTs are stored in One Segments
///                                    * Segment0, 32 locations= ((addr[7:0]>=0) & (addr[7:0]<32))
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x03200                      (P)
///     # 0x03200 PLUT                 
///               $PLUT                PLUT              MEM          
///                                    ###
///                                    * PLUT can only be programmed during Vertical Blank period.
///                                    * The PLUT has 32 Memory locations with 28 bit each. Its data format is {lut_val_Odd[13:0], lut_val_Even[13:0]}.
///                                    * LUTs are stored in One Segments
///                                    * Segment0, 32 locations= ((addr[7:0]>=0) & (addr[7:0]<32))
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x03400                      (P)
///     # 0x03400 SLUT                 
///               $SLUT                SLUT              MEM          
///                                    ###
///                                    * SLUT can only be programmed during Vertical Blank period.
///                                    * The SLUT has 32 Memory locations with 20 bit each. Its data format is {lut_val_Odd[9:0], lut_val_Even[9:0]}.
///                                    * LUTs are stored in One Segments
///                                    * Segment0, 32 locations= ((addr[7:0]>=0) & (addr[7:0]<32))
///                                    * PoweOnDefault values are not set by Hardware, need to be programmed by firmware initialization.
///                                    ###
///     @ 0x03600                      (W-)
///     #         # Stuffing bytes...
///               %% 4096
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:   14336B, bits:     261b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_GLUT
#define h_GLUT (){}

    #define     RA_GLUT_CTRL                                   0x0000

    #define     BA_GLUT_CTRL_IP_Sel                            0x0000
    #define     B16GLUT_CTRL_IP_Sel                            0x0000
    #define   LSb32GLUT_CTRL_IP_Sel                               0
    #define   LSb16GLUT_CTRL_IP_Sel                               0
    #define       bGLUT_CTRL_IP_Sel                            1
    #define   MSK32GLUT_CTRL_IP_Sel                               0x00000001
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_RAM                                    0x0004

    #define     BA_GLUT_RAM_rw_en                              0x0004
    #define     B16GLUT_RAM_rw_en                              0x0004
    #define   LSb32GLUT_RAM_rw_en                                 0
    #define   LSb16GLUT_RAM_rw_en                                 0
    #define       bGLUT_RAM_rw_en                              1
    #define   MSK32GLUT_RAM_rw_en                                 0x00000001

    #define     BA_GLUT_RAM_ram_sel                            0x0004
    #define     B16GLUT_RAM_ram_sel                            0x0004
    #define   LSb32GLUT_RAM_ram_sel                               1
    #define   LSb16GLUT_RAM_ram_sel                               1
    #define       bGLUT_RAM_ram_sel                            3
    #define   MSK32GLUT_RAM_ram_sel                               0x0000000E
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_LUT2D                                  0x0800
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_INLUT                                  0x1000
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_OUTLUT                                 0x1800
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_CLUT                                   0x2000
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_DLUT                                   0x2800
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_ILUT                                   0x3000
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_PLUT                                   0x3200
    ///////////////////////////////////////////////////////////
    #define     RA_GLUT_SLUT                                   0x3400
    ///////////////////////////////////////////////////////////

    typedef struct SIE_GLUT {
    ///////////////////////////////////////////////////////////
    #define   GET32GLUT_CTRL_IP_Sel(r32)                       _BFGET_(r32, 0, 0)
    #define   SET32GLUT_CTRL_IP_Sel(r32,v)                     _BFSET_(r32, 0, 0,v)
    #define   GET16GLUT_CTRL_IP_Sel(r16)                       _BFGET_(r16, 0, 0)
    #define   SET16GLUT_CTRL_IP_Sel(r16,v)                     _BFSET_(r16, 0, 0,v)

    #define     w32GLUT_CTRL                                   {\
            UNSG32 uCTRL_IP_Sel                                :  1;\
            UNSG32 RSVDx0_b1                                   : 31;\
          }
    union { UNSG32 u32GLUT_CTRL;
            struct w32GLUT_CTRL;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32GLUT_RAM_rw_en(r32)                         _BFGET_(r32, 0, 0)
    #define   SET32GLUT_RAM_rw_en(r32,v)                       _BFSET_(r32, 0, 0,v)
    #define   GET16GLUT_RAM_rw_en(r16)                         _BFGET_(r16, 0, 0)
    #define   SET16GLUT_RAM_rw_en(r16,v)                       _BFSET_(r16, 0, 0,v)

    #define   GET32GLUT_RAM_ram_sel(r32)                       _BFGET_(r32, 3, 1)
    #define   SET32GLUT_RAM_ram_sel(r32,v)                     _BFSET_(r32, 3, 1,v)
    #define   GET16GLUT_RAM_ram_sel(r16)                       _BFGET_(r16, 3, 1)
    #define   SET16GLUT_RAM_ram_sel(r16,v)                     _BFSET_(r16, 3, 1,v)

    #define     w32GLUT_RAM                                    {\
            UNSG32 uRAM_rw_en                                  :  1;\
            UNSG32 uRAM_ram_sel                                :  3;\
            UNSG32 RSVDx4_b4                                   : 28;\
          }
    union { UNSG32 u32GLUT_RAM;
            struct w32GLUT_RAM;
          };
    ///////////////////////////////////////////////////////////
             UNSG8 RSVDx8                                      [2040];
    ///////////////////////////////////////////////////////////
              SIE_LUT2D                                        ie_LUT2D;
             UNSG8 RSVD_LUT2D                                  [892];
    ///////////////////////////////////////////////////////////
              SIE_INLUT                                        ie_INLUT;
             UNSG8 RSVD_INLUT                                  [500];
    ///////////////////////////////////////////////////////////
              SIE_OUTLUT                                       ie_OUTLUT;
             UNSG8 RSVD_OUTLUT                                 [500];
    ///////////////////////////////////////////////////////////
              SIE_CLUT                                         ie_CLUT;
    ///////////////////////////////////////////////////////////
             UNSG8 RSVDx2200                                   [1536];
    ///////////////////////////////////////////////////////////
              SIE_DLUT                                         ie_DLUT;
             UNSG8 RSVD_DLUT                                   [512];
    ///////////////////////////////////////////////////////////
              SIE_ILUT                                         ie_ILUT;
    ///////////////////////////////////////////////////////////
              SIE_PLUT                                         ie_PLUT;
    ///////////////////////////////////////////////////////////
              SIE_SLUT                                         ie_SLUT;
    ///////////////////////////////////////////////////////////
             UNSG8 RSVDx3600                                   [512];
    ///////////////////////////////////////////////////////////
    } SIE_GLUT;

    typedef union  T32GLUT_CTRL
          { UNSG32 u32;
            struct w32GLUT_CTRL;
                 } T32GLUT_CTRL;
    typedef union  T32GLUT_RAM
          { UNSG32 u32;
            struct w32GLUT_RAM;
                 } T32GLUT_RAM;
    ///////////////////////////////////////////////////////////

    typedef union  TGLUT_CTRL
          { UNSG32 u32[1];
            struct {
            struct w32GLUT_CTRL;
                   };
                 } TGLUT_CTRL;
    typedef union  TGLUT_RAM
          { UNSG32 u32[1];
            struct {
            struct w32GLUT_RAM;
                   };
                 } TGLUT_RAM;

    ///////////////////////////////////////////////////////////
     SIGN32 GLUT_drvrd(SIE_GLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 GLUT_drvwr(SIE_GLUT *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void GLUT_reset(SIE_GLUT *p);
     SIGN32 GLUT_cmp  (SIE_GLUT *p, SIE_GLUT *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define GLUT_check(p,pie,pfx,hLOG) GLUT_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define GLUT_print(p,    pfx,hLOG) GLUT_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: GLUT
////////////////////////////////////////////////////////////



#ifdef __cplusplus
  }
#endif
#pragma  pack()

#endif
//////
/// ENDOFFILE: GLUT.h
////////////////////////////////////////////////////////////

