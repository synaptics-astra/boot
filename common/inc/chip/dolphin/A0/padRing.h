//////
/// don't edit! auto-generated by docc: padRing.h
////////////////////////////////////////////////////////////
#ifndef padRing_h
#define padRing_h (){}


#include "ctypes.h"

#pragma pack(1)
#ifdef __cplusplus
  extern "C" {
#endif

#ifndef _DOCC_H_BITOPS_
#define _DOCC_H_BITOPS_ (){}

    #define _bSETMASK_(b)                                      ((b)<32 ? (1<<((b)&31)) : 0)
    #define _NSETMASK_(msb,lsb)                                (_bSETMASK_((msb)+1)-_bSETMASK_(lsb))
    #define _bCLRMASK_(b)                                      (~_bSETMASK_(b))
    #define _NCLRMASK_(msb,lsb)                                (~_NSETMASK_(msb,lsb))
    #define _BFGET_(r,msb,lsb)                                 (_NSETMASK_((msb)-(lsb),0)&((r)>>(lsb)))
    #define _BFSET_(r,msb,lsb,v)                               do{ (r)&=_NCLRMASK_(msb,lsb); (r)|=_NSETMASK_(msb,lsb)&((v)<<(lsb)); }while(0)

#endif



//////
/// 
/// $INTERFACE padRing                                  (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  REG_PDB_CORE              0x1
///                                    : NORMAL                    0x1
///                                    : PWRDN                     0x0
///                                                 ###
///                                                 * When REG_PDB_CORE is logic '1', the regulator works in normal mode and consumes ~60uA current at typical 25degC. When REG_PDB_CORE is logic '0', the regulator works in power-down mode and consumes ~6uA current at typical 25degC.
///                                                 ###
///               %unsigned 1  REF_INT_EN                0x1
///                                    : NORMAL                    0x1
///                                    : REF_DOWN                  0x0
///                                                 ###
///                                                 * When REF_INT_EN='1', REF/REF_FT is generated internally. When REF_INT_EN='0', the internal REF circuit is powered down and the REF signal is brought down to 0.
///                                                 * Since we do not use HSIN pads in bg3, we do not use this setting.
///                                                 ###
///               %unsigned 1  V18EN_CORE                0x0
///               %unsigned 1  V25EN_CORE                0x0
///                                    ###
///                                    * V18EN_CORE and V25EN_CORE are settings for different IO supply level
///                                    * V18EN_CORE=0,V25EN_CORE=0 : 3.3V
///                                    * V18EN_CORE=0,V25EN_CORE=1 : 2.5V
///                                    * V18EN_CORE=1,V25EN_CORE=X : 1.5V, 1.5V or 1.8V
///                                    ###
///               %unsigned 4  ZP                        0x0
///                                    ###
///                                    * ZP[3:0] is used to program PMOS output driver strength for PADXDC_HSIOB. ZP[3:0]='1111' is the strongest setting.
///                                    ###
///               %unsigned 4  ZN                        0x0
///                                    ###
///                                    * ZN[3:0] is used to program NMOS output driver strength for PADXDC_HSIOB. ZN[3:0]='1111' is the strongest setting.
///                                    ###
///               %unsigned 4  CAL_ZP                    0x0
///                                    ###
///                                    * ZN / ZP signals for calibration pad.
///                                    * ZN / ZP signals of the output impedance calibration pad and the functional I/O pad should be separated.
///                                    ###
///               %unsigned 4  CAL_ZN                    0x0
///                                    ###
///                                    * ZN / ZP signals for calibration pad.
///                                    * ZN / ZP signals of the output impedance calibration pad and the functional I/O pad should be separated.
///                                    ###
///               %unsigned 1  CAL_P_EN                  0x0
///                                    ###
///                                    * CAL_P_EN is active high core signal. Needs to be asserted high to start the PMOS driver calibration
///                                    ###
///               %unsigned 1  CAL_N_EN                  0x0
///                                    ###
///                                    * CAL_N_EN is active high core signal. Needs to be asserted high to start the NMOS driver calibration. PMOS driver has to be calibrated first, and ZP_AFT_CAL[3:0] need to be set to the calibrated PMOS settings before CAL_N_EN is asserted high
///                                    ###
///               %unsigned 1  ODR_EN                    0x1
///                                    ###
///                                    * When off-chip resistor is used, please set ODR_EN=0. When internal resistor is used for calibration, please set ODR_EN=1 and choose a proper ODR[2:0] setting to achieve desired driver strength.
///                                    ###
///               %unsigned 3  ODR                       0x0
///                                    ###
///                                    * ODR[2:0] is used to adjust the internal reference resistor value for calibration without external resistor. ODR_EN need to be set to '1' to enable internal resistor.
///                                    ###
///               %unsigned 4  ZP_AFT_CAL                0x0
///                                    ###
///                                    * ZP_AFT_CAL[3:0] are active high signals at the core signal level. They should be fed in by the registers that stores the settings after the PMOS driver calibration
///                                    ###
///               %%        2          # Stuffing bits...
///     @ 0x00004 status               (R-)
///               %unsigned 1  CAL_P_INC                 
///                                    ###
///                                    * CAL_P_INC is the output of the comparator. When the pad voltage is lower than the internal reference voltage, CAL_P_INC is high (i.e. the output impedance of PMOS is higher than the desired impedance).
///                                    * In a calibration loop, CAL_P_INC high can be interpreted as a signal to increment ZP[3:0].
///                                    ###
///               %unsigned 1  CAL_N_INC                 
///                                    ###
///                                    * CAL_N_INC is the output of the comparator. When the pad voltage is higher than the internal reference voltage, CAL_N_INC is high (i.e. the output impedance of NMOS is higher than the desired impedance). In a calibration loop, CAL_N_INC high can be interpreted as a signal to increment ZN[3:0].
///                                    ###
///               %%        30         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       8B, bits:      32b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_padRing
#define h_padRing (){}

    #define     RA_padRing_ctrl                                0x0000

    #define     BA_padRing_ctrl_REG_PDB_CORE                   0x0000
    #define     B16padRing_ctrl_REG_PDB_CORE                   0x0000
    #define   LSb32padRing_ctrl_REG_PDB_CORE                      0
    #define   LSb16padRing_ctrl_REG_PDB_CORE                      0
    #define       bpadRing_ctrl_REG_PDB_CORE                   1
    #define   MSK32padRing_ctrl_REG_PDB_CORE                      0x00000001
    #define        padRing_ctrl_REG_PDB_CORE_NORMAL                         0x1
    #define        padRing_ctrl_REG_PDB_CORE_PWRDN                          0x0

    #define     BA_padRing_ctrl_REF_INT_EN                     0x0000
    #define     B16padRing_ctrl_REF_INT_EN                     0x0000
    #define   LSb32padRing_ctrl_REF_INT_EN                        1
    #define   LSb16padRing_ctrl_REF_INT_EN                        1
    #define       bpadRing_ctrl_REF_INT_EN                     1
    #define   MSK32padRing_ctrl_REF_INT_EN                        0x00000002
    #define        padRing_ctrl_REF_INT_EN_NORMAL                           0x1
    #define        padRing_ctrl_REF_INT_EN_REF_DOWN                         0x0

    #define     BA_padRing_ctrl_V18EN_CORE                     0x0000
    #define     B16padRing_ctrl_V18EN_CORE                     0x0000
    #define   LSb32padRing_ctrl_V18EN_CORE                        2
    #define   LSb16padRing_ctrl_V18EN_CORE                        2
    #define       bpadRing_ctrl_V18EN_CORE                     1
    #define   MSK32padRing_ctrl_V18EN_CORE                        0x00000004

    #define     BA_padRing_ctrl_V25EN_CORE                     0x0000
    #define     B16padRing_ctrl_V25EN_CORE                     0x0000
    #define   LSb32padRing_ctrl_V25EN_CORE                        3
    #define   LSb16padRing_ctrl_V25EN_CORE                        3
    #define       bpadRing_ctrl_V25EN_CORE                     1
    #define   MSK32padRing_ctrl_V25EN_CORE                        0x00000008

    #define     BA_padRing_ctrl_ZP                             0x0000
    #define     B16padRing_ctrl_ZP                             0x0000
    #define   LSb32padRing_ctrl_ZP                                4
    #define   LSb16padRing_ctrl_ZP                                4
    #define       bpadRing_ctrl_ZP                             4
    #define   MSK32padRing_ctrl_ZP                                0x000000F0

    #define     BA_padRing_ctrl_ZN                             0x0001
    #define     B16padRing_ctrl_ZN                             0x0000
    #define   LSb32padRing_ctrl_ZN                                8
    #define   LSb16padRing_ctrl_ZN                                8
    #define       bpadRing_ctrl_ZN                             4
    #define   MSK32padRing_ctrl_ZN                                0x00000F00

    #define     BA_padRing_ctrl_CAL_ZP                         0x0001
    #define     B16padRing_ctrl_CAL_ZP                         0x0000
    #define   LSb32padRing_ctrl_CAL_ZP                            12
    #define   LSb16padRing_ctrl_CAL_ZP                            12
    #define       bpadRing_ctrl_CAL_ZP                         4
    #define   MSK32padRing_ctrl_CAL_ZP                            0x0000F000

    #define     BA_padRing_ctrl_CAL_ZN                         0x0002
    #define     B16padRing_ctrl_CAL_ZN                         0x0002
    #define   LSb32padRing_ctrl_CAL_ZN                            16
    #define   LSb16padRing_ctrl_CAL_ZN                            0
    #define       bpadRing_ctrl_CAL_ZN                         4
    #define   MSK32padRing_ctrl_CAL_ZN                            0x000F0000

    #define     BA_padRing_ctrl_CAL_P_EN                       0x0002
    #define     B16padRing_ctrl_CAL_P_EN                       0x0002
    #define   LSb32padRing_ctrl_CAL_P_EN                          20
    #define   LSb16padRing_ctrl_CAL_P_EN                          4
    #define       bpadRing_ctrl_CAL_P_EN                       1
    #define   MSK32padRing_ctrl_CAL_P_EN                          0x00100000

    #define     BA_padRing_ctrl_CAL_N_EN                       0x0002
    #define     B16padRing_ctrl_CAL_N_EN                       0x0002
    #define   LSb32padRing_ctrl_CAL_N_EN                          21
    #define   LSb16padRing_ctrl_CAL_N_EN                          5
    #define       bpadRing_ctrl_CAL_N_EN                       1
    #define   MSK32padRing_ctrl_CAL_N_EN                          0x00200000

    #define     BA_padRing_ctrl_ODR_EN                         0x0002
    #define     B16padRing_ctrl_ODR_EN                         0x0002
    #define   LSb32padRing_ctrl_ODR_EN                            22
    #define   LSb16padRing_ctrl_ODR_EN                            6
    #define       bpadRing_ctrl_ODR_EN                         1
    #define   MSK32padRing_ctrl_ODR_EN                            0x00400000

    #define     BA_padRing_ctrl_ODR                            0x0002
    #define     B16padRing_ctrl_ODR                            0x0002
    #define   LSb32padRing_ctrl_ODR                               23
    #define   LSb16padRing_ctrl_ODR                               7
    #define       bpadRing_ctrl_ODR                            3
    #define   MSK32padRing_ctrl_ODR                               0x03800000

    #define     BA_padRing_ctrl_ZP_AFT_CAL                     0x0003
    #define     B16padRing_ctrl_ZP_AFT_CAL                     0x0002
    #define   LSb32padRing_ctrl_ZP_AFT_CAL                        26
    #define   LSb16padRing_ctrl_ZP_AFT_CAL                        10
    #define       bpadRing_ctrl_ZP_AFT_CAL                     4
    #define   MSK32padRing_ctrl_ZP_AFT_CAL                        0x3C000000
    ///////////////////////////////////////////////////////////
    #define     RA_padRing_status                              0x0004

    #define     BA_padRing_status_CAL_P_INC                    0x0004
    #define     B16padRing_status_CAL_P_INC                    0x0004
    #define   LSb32padRing_status_CAL_P_INC                       0
    #define   LSb16padRing_status_CAL_P_INC                       0
    #define       bpadRing_status_CAL_P_INC                    1
    #define   MSK32padRing_status_CAL_P_INC                       0x00000001

    #define     BA_padRing_status_CAL_N_INC                    0x0004
    #define     B16padRing_status_CAL_N_INC                    0x0004
    #define   LSb32padRing_status_CAL_N_INC                       1
    #define   LSb16padRing_status_CAL_N_INC                       1
    #define       bpadRing_status_CAL_N_INC                    1
    #define   MSK32padRing_status_CAL_N_INC                       0x00000002
    ///////////////////////////////////////////////////////////

    typedef struct SIE_padRing {
    ///////////////////////////////////////////////////////////
    #define   GET32padRing_ctrl_REG_PDB_CORE(r32)              _BFGET_(r32, 0, 0)
    #define   SET32padRing_ctrl_REG_PDB_CORE(r32,v)            _BFSET_(r32, 0, 0,v)
    #define   GET16padRing_ctrl_REG_PDB_CORE(r16)              _BFGET_(r16, 0, 0)
    #define   SET16padRing_ctrl_REG_PDB_CORE(r16,v)            _BFSET_(r16, 0, 0,v)

    #define   GET32padRing_ctrl_REF_INT_EN(r32)                _BFGET_(r32, 1, 1)
    #define   SET32padRing_ctrl_REF_INT_EN(r32,v)              _BFSET_(r32, 1, 1,v)
    #define   GET16padRing_ctrl_REF_INT_EN(r16)                _BFGET_(r16, 1, 1)
    #define   SET16padRing_ctrl_REF_INT_EN(r16,v)              _BFSET_(r16, 1, 1,v)

    #define   GET32padRing_ctrl_V18EN_CORE(r32)                _BFGET_(r32, 2, 2)
    #define   SET32padRing_ctrl_V18EN_CORE(r32,v)              _BFSET_(r32, 2, 2,v)
    #define   GET16padRing_ctrl_V18EN_CORE(r16)                _BFGET_(r16, 2, 2)
    #define   SET16padRing_ctrl_V18EN_CORE(r16,v)              _BFSET_(r16, 2, 2,v)

    #define   GET32padRing_ctrl_V25EN_CORE(r32)                _BFGET_(r32, 3, 3)
    #define   SET32padRing_ctrl_V25EN_CORE(r32,v)              _BFSET_(r32, 3, 3,v)
    #define   GET16padRing_ctrl_V25EN_CORE(r16)                _BFGET_(r16, 3, 3)
    #define   SET16padRing_ctrl_V25EN_CORE(r16,v)              _BFSET_(r16, 3, 3,v)

    #define   GET32padRing_ctrl_ZP(r32)                        _BFGET_(r32, 7, 4)
    #define   SET32padRing_ctrl_ZP(r32,v)                      _BFSET_(r32, 7, 4,v)
    #define   GET16padRing_ctrl_ZP(r16)                        _BFGET_(r16, 7, 4)
    #define   SET16padRing_ctrl_ZP(r16,v)                      _BFSET_(r16, 7, 4,v)

    #define   GET32padRing_ctrl_ZN(r32)                        _BFGET_(r32,11, 8)
    #define   SET32padRing_ctrl_ZN(r32,v)                      _BFSET_(r32,11, 8,v)
    #define   GET16padRing_ctrl_ZN(r16)                        _BFGET_(r16,11, 8)
    #define   SET16padRing_ctrl_ZN(r16,v)                      _BFSET_(r16,11, 8,v)

    #define   GET32padRing_ctrl_CAL_ZP(r32)                    _BFGET_(r32,15,12)
    #define   SET32padRing_ctrl_CAL_ZP(r32,v)                  _BFSET_(r32,15,12,v)
    #define   GET16padRing_ctrl_CAL_ZP(r16)                    _BFGET_(r16,15,12)
    #define   SET16padRing_ctrl_CAL_ZP(r16,v)                  _BFSET_(r16,15,12,v)

    #define   GET32padRing_ctrl_CAL_ZN(r32)                    _BFGET_(r32,19,16)
    #define   SET32padRing_ctrl_CAL_ZN(r32,v)                  _BFSET_(r32,19,16,v)
    #define   GET16padRing_ctrl_CAL_ZN(r16)                    _BFGET_(r16, 3, 0)
    #define   SET16padRing_ctrl_CAL_ZN(r16,v)                  _BFSET_(r16, 3, 0,v)

    #define   GET32padRing_ctrl_CAL_P_EN(r32)                  _BFGET_(r32,20,20)
    #define   SET32padRing_ctrl_CAL_P_EN(r32,v)                _BFSET_(r32,20,20,v)
    #define   GET16padRing_ctrl_CAL_P_EN(r16)                  _BFGET_(r16, 4, 4)
    #define   SET16padRing_ctrl_CAL_P_EN(r16,v)                _BFSET_(r16, 4, 4,v)

    #define   GET32padRing_ctrl_CAL_N_EN(r32)                  _BFGET_(r32,21,21)
    #define   SET32padRing_ctrl_CAL_N_EN(r32,v)                _BFSET_(r32,21,21,v)
    #define   GET16padRing_ctrl_CAL_N_EN(r16)                  _BFGET_(r16, 5, 5)
    #define   SET16padRing_ctrl_CAL_N_EN(r16,v)                _BFSET_(r16, 5, 5,v)

    #define   GET32padRing_ctrl_ODR_EN(r32)                    _BFGET_(r32,22,22)
    #define   SET32padRing_ctrl_ODR_EN(r32,v)                  _BFSET_(r32,22,22,v)
    #define   GET16padRing_ctrl_ODR_EN(r16)                    _BFGET_(r16, 6, 6)
    #define   SET16padRing_ctrl_ODR_EN(r16,v)                  _BFSET_(r16, 6, 6,v)

    #define   GET32padRing_ctrl_ODR(r32)                       _BFGET_(r32,25,23)
    #define   SET32padRing_ctrl_ODR(r32,v)                     _BFSET_(r32,25,23,v)
    #define   GET16padRing_ctrl_ODR(r16)                       _BFGET_(r16, 9, 7)
    #define   SET16padRing_ctrl_ODR(r16,v)                     _BFSET_(r16, 9, 7,v)

    #define   GET32padRing_ctrl_ZP_AFT_CAL(r32)                _BFGET_(r32,29,26)
    #define   SET32padRing_ctrl_ZP_AFT_CAL(r32,v)              _BFSET_(r32,29,26,v)
    #define   GET16padRing_ctrl_ZP_AFT_CAL(r16)                _BFGET_(r16,13,10)
    #define   SET16padRing_ctrl_ZP_AFT_CAL(r16,v)              _BFSET_(r16,13,10,v)

    #define     w32padRing_ctrl                                {\
            UNSG32 uctrl_REG_PDB_CORE                          :  1;\
            UNSG32 uctrl_REF_INT_EN                            :  1;\
            UNSG32 uctrl_V18EN_CORE                            :  1;\
            UNSG32 uctrl_V25EN_CORE                            :  1;\
            UNSG32 uctrl_ZP                                    :  4;\
            UNSG32 uctrl_ZN                                    :  4;\
            UNSG32 uctrl_CAL_ZP                                :  4;\
            UNSG32 uctrl_CAL_ZN                                :  4;\
            UNSG32 uctrl_CAL_P_EN                              :  1;\
            UNSG32 uctrl_CAL_N_EN                              :  1;\
            UNSG32 uctrl_ODR_EN                                :  1;\
            UNSG32 uctrl_ODR                                   :  3;\
            UNSG32 uctrl_ZP_AFT_CAL                            :  4;\
            UNSG32 RSVDx0_b30                                  :  2;\
          }
    union { UNSG32 u32padRing_ctrl;
            struct w32padRing_ctrl;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32padRing_status_CAL_P_INC(r32)               _BFGET_(r32, 0, 0)
    #define   SET32padRing_status_CAL_P_INC(r32,v)             _BFSET_(r32, 0, 0,v)
    #define   GET16padRing_status_CAL_P_INC(r16)               _BFGET_(r16, 0, 0)
    #define   SET16padRing_status_CAL_P_INC(r16,v)             _BFSET_(r16, 0, 0,v)

    #define   GET32padRing_status_CAL_N_INC(r32)               _BFGET_(r32, 1, 1)
    #define   SET32padRing_status_CAL_N_INC(r32,v)             _BFSET_(r32, 1, 1,v)
    #define   GET16padRing_status_CAL_N_INC(r16)               _BFGET_(r16, 1, 1)
    #define   SET16padRing_status_CAL_N_INC(r16,v)             _BFSET_(r16, 1, 1,v)

    #define     w32padRing_status                              {\
            UNSG32 ustatus_CAL_P_INC                           :  1;\
            UNSG32 ustatus_CAL_N_INC                           :  1;\
            UNSG32 RSVDx4_b2                                   : 30;\
          }
    union { UNSG32 u32padRing_status;
            struct w32padRing_status;
          };
    ///////////////////////////////////////////////////////////
    } SIE_padRing;

    typedef union  T32padRing_ctrl
          { UNSG32 u32;
            struct w32padRing_ctrl;
                 } T32padRing_ctrl;
    typedef union  T32padRing_status
          { UNSG32 u32;
            struct w32padRing_status;
                 } T32padRing_status;
    ///////////////////////////////////////////////////////////

    typedef union  TpadRing_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32padRing_ctrl;
                   };
                 } TpadRing_ctrl;
    typedef union  TpadRing_status
          { UNSG32 u32[1];
            struct {
            struct w32padRing_status;
                   };
                 } TpadRing_status;

    ///////////////////////////////////////////////////////////
     SIGN32 padRing_drvrd(SIE_padRing *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 padRing_drvwr(SIE_padRing *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void padRing_reset(SIE_padRing *p);
     SIGN32 padRing_cmp  (SIE_padRing *p, SIE_padRing *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define padRing_check(p,pie,pfx,hLOG) padRing_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define padRing_print(p,    pfx,hLOG) padRing_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: padRing
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE padRingV18                               (4,4)
///     ###
///     * Default voltage setting is 1.8V
///     ###
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  REG_PDB_CORE              0x1
///                                    : NORMAL                    0x1
///                                    : PWRDN                     0x0
///                                                 ###
///                                                 * When REG_PDB_CORE is logic '1', the regulator works in normal mode and consumes ~60uA current at typical 25degC. When REG_PDB_CORE is logic '0', the regulator works in power-down mode and consumes ~6uA current at typical 25degC.
///                                                 ###
///               %unsigned 1  REF_INT_EN                0x1
///                                    : NORMAL                    0x1
///                                    : REF_DOWN                  0x0
///                                                 ###
///                                                 * When REF_INT_EN='1', REF/REF_FT is generated internally. When REF_INT_EN='0', the internal REF circuit is powered down and the REF signal is brought down to 0.
///                                                 * Since we do not use HSIN pads in bg3, we do not use this setting.
///                                                 ###
///               %unsigned 1  V18EN_CORE                0x1
///               %unsigned 1  V25EN_CORE                0x0
///                                    ###
///                                    * V18EN_CORE and V25EN_CORE are settings for different IO supply level
///                                    * V18EN_CORE=0,V25EN_CORE=0 : 3.3V
///                                    * V18EN_CORE=0,V25EN_CORE=1 : 2.5V
///                                    * V18EN_CORE=1,V25EN_CORE=X : 1.5V, 1.5V or 1.8V
///                                    ###
///               %unsigned 4  ZP                        0x0
///                                    ###
///                                    * ZP[3:0] is used to program PMOS output driver strength for PADXDC_HSIOB. ZP[3:0]='1111' is the strongest setting.
///                                    ###
///               %unsigned 4  ZN                        0x0
///                                    ###
///                                    * ZN[3:0] is used to program NMOS output driver strength for PADXDC_HSIOB. ZN[3:0]='1111' is the strongest setting.
///                                    ###
///               %unsigned 4  CAL_ZP                    0x0
///                                    ###
///                                    * ZN / ZP signals for calibration pad.
///                                    * ZN / ZP signals of the output impedance calibration pad and the functional I/O pad should be separated.
///                                    ###
///               %unsigned 4  CAL_ZN                    0x0
///                                    ###
///                                    * ZN / ZP signals for calibration pad.
///                                    * ZN / ZP signals of the output impedance calibration pad and the functional I/O pad should be separated.
///                                    ###
///               %unsigned 1  CAL_P_EN                  0x0
///                                    ###
///                                    * CAL_P_EN is active high core signal. Needs to be asserted high to start the PMOS driver calibration
///                                    ###
///               %unsigned 1  CAL_N_EN                  0x0
///                                    ###
///                                    * CAL_N_EN is active high core signal. Needs to be asserted high to start the NMOS driver calibration. PMOS driver has to be calibrated first, and ZP_AFT_CAL[3:0] need to be set to the calibrated PMOS settings before CAL_N_EN is asserted high
///                                    ###
///               %unsigned 1  ODR_EN                    0x1
///                                    ###
///                                    * When off-chip resistor is used, please set ODR_EN=0. When internal resistor is used for calibration, please set ODR_EN=1 and choose a proper ODR[2:0] setting to achieve desired driver strength.
///                                    ###
///               %unsigned 3  ODR                       0x0
///                                    ###
///                                    * ODR[2:0] is used to adjust the internal reference resistor value for calibration without external resistor. ODR_EN need to be set to '1' to enable internal resistor.
///                                    ###
///               %unsigned 4  ZP_AFT_CAL                0x0
///                                    ###
///                                    * ZP_AFT_CAL[3:0] are active high signals at the core signal level. They should be fed in by the registers that stores the settings after the PMOS driver calibration
///                                    ###
///               %%        2          # Stuffing bits...
///     @ 0x00004 status               (R-)
///               %unsigned 1  CAL_P_INC                 
///                                    ###
///                                    * CAL_P_INC is the output of the comparator. When the pad voltage is lower than the internal reference voltage, CAL_P_INC is high (i.e. the output impedance of PMOS is higher than the desired impedance).
///                                    * In a calibration loop, CAL_P_INC high can be interpreted as a signal to increment ZP[3:0].
///                                    ###
///               %unsigned 1  CAL_N_INC                 
///                                    ###
///                                    * CAL_N_INC is the output of the comparator. When the pad voltage is higher than the internal reference voltage, CAL_N_INC is high (i.e. the output impedance of NMOS is higher than the desired impedance). In a calibration loop, CAL_N_INC high can be interpreted as a signal to increment ZN[3:0].
///                                    ###
///               %%        30         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       8B, bits:      32b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_padRingV18
#define h_padRingV18 (){}

    #define     RA_padRingV18_ctrl                             0x0000

    #define     BA_padRingV18_ctrl_REG_PDB_CORE                0x0000
    #define     B16padRingV18_ctrl_REG_PDB_CORE                0x0000
    #define   LSb32padRingV18_ctrl_REG_PDB_CORE                   0
    #define   LSb16padRingV18_ctrl_REG_PDB_CORE                   0
    #define       bpadRingV18_ctrl_REG_PDB_CORE                1
    #define   MSK32padRingV18_ctrl_REG_PDB_CORE                   0x00000001
    #define        padRingV18_ctrl_REG_PDB_CORE_NORMAL                      0x1
    #define        padRingV18_ctrl_REG_PDB_CORE_PWRDN                       0x0

    #define     BA_padRingV18_ctrl_REF_INT_EN                  0x0000
    #define     B16padRingV18_ctrl_REF_INT_EN                  0x0000
    #define   LSb32padRingV18_ctrl_REF_INT_EN                     1
    #define   LSb16padRingV18_ctrl_REF_INT_EN                     1
    #define       bpadRingV18_ctrl_REF_INT_EN                  1
    #define   MSK32padRingV18_ctrl_REF_INT_EN                     0x00000002
    #define        padRingV18_ctrl_REF_INT_EN_NORMAL                        0x1
    #define        padRingV18_ctrl_REF_INT_EN_REF_DOWN                      0x0

    #define     BA_padRingV18_ctrl_V18EN_CORE                  0x0000
    #define     B16padRingV18_ctrl_V18EN_CORE                  0x0000
    #define   LSb32padRingV18_ctrl_V18EN_CORE                     2
    #define   LSb16padRingV18_ctrl_V18EN_CORE                     2
    #define       bpadRingV18_ctrl_V18EN_CORE                  1
    #define   MSK32padRingV18_ctrl_V18EN_CORE                     0x00000004

    #define     BA_padRingV18_ctrl_V25EN_CORE                  0x0000
    #define     B16padRingV18_ctrl_V25EN_CORE                  0x0000
    #define   LSb32padRingV18_ctrl_V25EN_CORE                     3
    #define   LSb16padRingV18_ctrl_V25EN_CORE                     3
    #define       bpadRingV18_ctrl_V25EN_CORE                  1
    #define   MSK32padRingV18_ctrl_V25EN_CORE                     0x00000008

    #define     BA_padRingV18_ctrl_ZP                          0x0000
    #define     B16padRingV18_ctrl_ZP                          0x0000
    #define   LSb32padRingV18_ctrl_ZP                             4
    #define   LSb16padRingV18_ctrl_ZP                             4
    #define       bpadRingV18_ctrl_ZP                          4
    #define   MSK32padRingV18_ctrl_ZP                             0x000000F0

    #define     BA_padRingV18_ctrl_ZN                          0x0001
    #define     B16padRingV18_ctrl_ZN                          0x0000
    #define   LSb32padRingV18_ctrl_ZN                             8
    #define   LSb16padRingV18_ctrl_ZN                             8
    #define       bpadRingV18_ctrl_ZN                          4
    #define   MSK32padRingV18_ctrl_ZN                             0x00000F00

    #define     BA_padRingV18_ctrl_CAL_ZP                      0x0001
    #define     B16padRingV18_ctrl_CAL_ZP                      0x0000
    #define   LSb32padRingV18_ctrl_CAL_ZP                         12
    #define   LSb16padRingV18_ctrl_CAL_ZP                         12
    #define       bpadRingV18_ctrl_CAL_ZP                      4
    #define   MSK32padRingV18_ctrl_CAL_ZP                         0x0000F000

    #define     BA_padRingV18_ctrl_CAL_ZN                      0x0002
    #define     B16padRingV18_ctrl_CAL_ZN                      0x0002
    #define   LSb32padRingV18_ctrl_CAL_ZN                         16
    #define   LSb16padRingV18_ctrl_CAL_ZN                         0
    #define       bpadRingV18_ctrl_CAL_ZN                      4
    #define   MSK32padRingV18_ctrl_CAL_ZN                         0x000F0000

    #define     BA_padRingV18_ctrl_CAL_P_EN                    0x0002
    #define     B16padRingV18_ctrl_CAL_P_EN                    0x0002
    #define   LSb32padRingV18_ctrl_CAL_P_EN                       20
    #define   LSb16padRingV18_ctrl_CAL_P_EN                       4
    #define       bpadRingV18_ctrl_CAL_P_EN                    1
    #define   MSK32padRingV18_ctrl_CAL_P_EN                       0x00100000

    #define     BA_padRingV18_ctrl_CAL_N_EN                    0x0002
    #define     B16padRingV18_ctrl_CAL_N_EN                    0x0002
    #define   LSb32padRingV18_ctrl_CAL_N_EN                       21
    #define   LSb16padRingV18_ctrl_CAL_N_EN                       5
    #define       bpadRingV18_ctrl_CAL_N_EN                    1
    #define   MSK32padRingV18_ctrl_CAL_N_EN                       0x00200000

    #define     BA_padRingV18_ctrl_ODR_EN                      0x0002
    #define     B16padRingV18_ctrl_ODR_EN                      0x0002
    #define   LSb32padRingV18_ctrl_ODR_EN                         22
    #define   LSb16padRingV18_ctrl_ODR_EN                         6
    #define       bpadRingV18_ctrl_ODR_EN                      1
    #define   MSK32padRingV18_ctrl_ODR_EN                         0x00400000

    #define     BA_padRingV18_ctrl_ODR                         0x0002
    #define     B16padRingV18_ctrl_ODR                         0x0002
    #define   LSb32padRingV18_ctrl_ODR                            23
    #define   LSb16padRingV18_ctrl_ODR                            7
    #define       bpadRingV18_ctrl_ODR                         3
    #define   MSK32padRingV18_ctrl_ODR                            0x03800000

    #define     BA_padRingV18_ctrl_ZP_AFT_CAL                  0x0003
    #define     B16padRingV18_ctrl_ZP_AFT_CAL                  0x0002
    #define   LSb32padRingV18_ctrl_ZP_AFT_CAL                     26
    #define   LSb16padRingV18_ctrl_ZP_AFT_CAL                     10
    #define       bpadRingV18_ctrl_ZP_AFT_CAL                  4
    #define   MSK32padRingV18_ctrl_ZP_AFT_CAL                     0x3C000000
    ///////////////////////////////////////////////////////////
    #define     RA_padRingV18_status                           0x0004

    #define     BA_padRingV18_status_CAL_P_INC                 0x0004
    #define     B16padRingV18_status_CAL_P_INC                 0x0004
    #define   LSb32padRingV18_status_CAL_P_INC                    0
    #define   LSb16padRingV18_status_CAL_P_INC                    0
    #define       bpadRingV18_status_CAL_P_INC                 1
    #define   MSK32padRingV18_status_CAL_P_INC                    0x00000001

    #define     BA_padRingV18_status_CAL_N_INC                 0x0004
    #define     B16padRingV18_status_CAL_N_INC                 0x0004
    #define   LSb32padRingV18_status_CAL_N_INC                    1
    #define   LSb16padRingV18_status_CAL_N_INC                    1
    #define       bpadRingV18_status_CAL_N_INC                 1
    #define   MSK32padRingV18_status_CAL_N_INC                    0x00000002
    ///////////////////////////////////////////////////////////

    typedef struct SIE_padRingV18 {
    ///////////////////////////////////////////////////////////
    #define   GET32padRingV18_ctrl_REG_PDB_CORE(r32)           _BFGET_(r32, 0, 0)
    #define   SET32padRingV18_ctrl_REG_PDB_CORE(r32,v)         _BFSET_(r32, 0, 0,v)
    #define   GET16padRingV18_ctrl_REG_PDB_CORE(r16)           _BFGET_(r16, 0, 0)
    #define   SET16padRingV18_ctrl_REG_PDB_CORE(r16,v)         _BFSET_(r16, 0, 0,v)

    #define   GET32padRingV18_ctrl_REF_INT_EN(r32)             _BFGET_(r32, 1, 1)
    #define   SET32padRingV18_ctrl_REF_INT_EN(r32,v)           _BFSET_(r32, 1, 1,v)
    #define   GET16padRingV18_ctrl_REF_INT_EN(r16)             _BFGET_(r16, 1, 1)
    #define   SET16padRingV18_ctrl_REF_INT_EN(r16,v)           _BFSET_(r16, 1, 1,v)

    #define   GET32padRingV18_ctrl_V18EN_CORE(r32)             _BFGET_(r32, 2, 2)
    #define   SET32padRingV18_ctrl_V18EN_CORE(r32,v)           _BFSET_(r32, 2, 2,v)
    #define   GET16padRingV18_ctrl_V18EN_CORE(r16)             _BFGET_(r16, 2, 2)
    #define   SET16padRingV18_ctrl_V18EN_CORE(r16,v)           _BFSET_(r16, 2, 2,v)

    #define   GET32padRingV18_ctrl_V25EN_CORE(r32)             _BFGET_(r32, 3, 3)
    #define   SET32padRingV18_ctrl_V25EN_CORE(r32,v)           _BFSET_(r32, 3, 3,v)
    #define   GET16padRingV18_ctrl_V25EN_CORE(r16)             _BFGET_(r16, 3, 3)
    #define   SET16padRingV18_ctrl_V25EN_CORE(r16,v)           _BFSET_(r16, 3, 3,v)

    #define   GET32padRingV18_ctrl_ZP(r32)                     _BFGET_(r32, 7, 4)
    #define   SET32padRingV18_ctrl_ZP(r32,v)                   _BFSET_(r32, 7, 4,v)
    #define   GET16padRingV18_ctrl_ZP(r16)                     _BFGET_(r16, 7, 4)
    #define   SET16padRingV18_ctrl_ZP(r16,v)                   _BFSET_(r16, 7, 4,v)

    #define   GET32padRingV18_ctrl_ZN(r32)                     _BFGET_(r32,11, 8)
    #define   SET32padRingV18_ctrl_ZN(r32,v)                   _BFSET_(r32,11, 8,v)
    #define   GET16padRingV18_ctrl_ZN(r16)                     _BFGET_(r16,11, 8)
    #define   SET16padRingV18_ctrl_ZN(r16,v)                   _BFSET_(r16,11, 8,v)

    #define   GET32padRingV18_ctrl_CAL_ZP(r32)                 _BFGET_(r32,15,12)
    #define   SET32padRingV18_ctrl_CAL_ZP(r32,v)               _BFSET_(r32,15,12,v)
    #define   GET16padRingV18_ctrl_CAL_ZP(r16)                 _BFGET_(r16,15,12)
    #define   SET16padRingV18_ctrl_CAL_ZP(r16,v)               _BFSET_(r16,15,12,v)

    #define   GET32padRingV18_ctrl_CAL_ZN(r32)                 _BFGET_(r32,19,16)
    #define   SET32padRingV18_ctrl_CAL_ZN(r32,v)               _BFSET_(r32,19,16,v)
    #define   GET16padRingV18_ctrl_CAL_ZN(r16)                 _BFGET_(r16, 3, 0)
    #define   SET16padRingV18_ctrl_CAL_ZN(r16,v)               _BFSET_(r16, 3, 0,v)

    #define   GET32padRingV18_ctrl_CAL_P_EN(r32)               _BFGET_(r32,20,20)
    #define   SET32padRingV18_ctrl_CAL_P_EN(r32,v)             _BFSET_(r32,20,20,v)
    #define   GET16padRingV18_ctrl_CAL_P_EN(r16)               _BFGET_(r16, 4, 4)
    #define   SET16padRingV18_ctrl_CAL_P_EN(r16,v)             _BFSET_(r16, 4, 4,v)

    #define   GET32padRingV18_ctrl_CAL_N_EN(r32)               _BFGET_(r32,21,21)
    #define   SET32padRingV18_ctrl_CAL_N_EN(r32,v)             _BFSET_(r32,21,21,v)
    #define   GET16padRingV18_ctrl_CAL_N_EN(r16)               _BFGET_(r16, 5, 5)
    #define   SET16padRingV18_ctrl_CAL_N_EN(r16,v)             _BFSET_(r16, 5, 5,v)

    #define   GET32padRingV18_ctrl_ODR_EN(r32)                 _BFGET_(r32,22,22)
    #define   SET32padRingV18_ctrl_ODR_EN(r32,v)               _BFSET_(r32,22,22,v)
    #define   GET16padRingV18_ctrl_ODR_EN(r16)                 _BFGET_(r16, 6, 6)
    #define   SET16padRingV18_ctrl_ODR_EN(r16,v)               _BFSET_(r16, 6, 6,v)

    #define   GET32padRingV18_ctrl_ODR(r32)                    _BFGET_(r32,25,23)
    #define   SET32padRingV18_ctrl_ODR(r32,v)                  _BFSET_(r32,25,23,v)
    #define   GET16padRingV18_ctrl_ODR(r16)                    _BFGET_(r16, 9, 7)
    #define   SET16padRingV18_ctrl_ODR(r16,v)                  _BFSET_(r16, 9, 7,v)

    #define   GET32padRingV18_ctrl_ZP_AFT_CAL(r32)             _BFGET_(r32,29,26)
    #define   SET32padRingV18_ctrl_ZP_AFT_CAL(r32,v)           _BFSET_(r32,29,26,v)
    #define   GET16padRingV18_ctrl_ZP_AFT_CAL(r16)             _BFGET_(r16,13,10)
    #define   SET16padRingV18_ctrl_ZP_AFT_CAL(r16,v)           _BFSET_(r16,13,10,v)

    #define     w32padRingV18_ctrl                             {\
            UNSG32 uctrl_REG_PDB_CORE                          :  1;\
            UNSG32 uctrl_REF_INT_EN                            :  1;\
            UNSG32 uctrl_V18EN_CORE                            :  1;\
            UNSG32 uctrl_V25EN_CORE                            :  1;\
            UNSG32 uctrl_ZP                                    :  4;\
            UNSG32 uctrl_ZN                                    :  4;\
            UNSG32 uctrl_CAL_ZP                                :  4;\
            UNSG32 uctrl_CAL_ZN                                :  4;\
            UNSG32 uctrl_CAL_P_EN                              :  1;\
            UNSG32 uctrl_CAL_N_EN                              :  1;\
            UNSG32 uctrl_ODR_EN                                :  1;\
            UNSG32 uctrl_ODR                                   :  3;\
            UNSG32 uctrl_ZP_AFT_CAL                            :  4;\
            UNSG32 RSVDx0_b30                                  :  2;\
          }
    union { UNSG32 u32padRingV18_ctrl;
            struct w32padRingV18_ctrl;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32padRingV18_status_CAL_P_INC(r32)            _BFGET_(r32, 0, 0)
    #define   SET32padRingV18_status_CAL_P_INC(r32,v)          _BFSET_(r32, 0, 0,v)
    #define   GET16padRingV18_status_CAL_P_INC(r16)            _BFGET_(r16, 0, 0)
    #define   SET16padRingV18_status_CAL_P_INC(r16,v)          _BFSET_(r16, 0, 0,v)

    #define   GET32padRingV18_status_CAL_N_INC(r32)            _BFGET_(r32, 1, 1)
    #define   SET32padRingV18_status_CAL_N_INC(r32,v)          _BFSET_(r32, 1, 1,v)
    #define   GET16padRingV18_status_CAL_N_INC(r16)            _BFGET_(r16, 1, 1)
    #define   SET16padRingV18_status_CAL_N_INC(r16,v)          _BFSET_(r16, 1, 1,v)

    #define     w32padRingV18_status                           {\
            UNSG32 ustatus_CAL_P_INC                           :  1;\
            UNSG32 ustatus_CAL_N_INC                           :  1;\
            UNSG32 RSVDx4_b2                                   : 30;\
          }
    union { UNSG32 u32padRingV18_status;
            struct w32padRingV18_status;
          };
    ///////////////////////////////////////////////////////////
    } SIE_padRingV18;

    typedef union  T32padRingV18_ctrl
          { UNSG32 u32;
            struct w32padRingV18_ctrl;
                 } T32padRingV18_ctrl;
    typedef union  T32padRingV18_status
          { UNSG32 u32;
            struct w32padRingV18_status;
                 } T32padRingV18_status;
    ///////////////////////////////////////////////////////////

    typedef union  TpadRingV18_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32padRingV18_ctrl;
                   };
                 } TpadRingV18_ctrl;
    typedef union  TpadRingV18_status
          { UNSG32 u32[1];
            struct {
            struct w32padRingV18_status;
                   };
                 } TpadRingV18_status;

    ///////////////////////////////////////////////////////////
     SIGN32 padRingV18_drvrd(SIE_padRingV18 *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 padRingV18_drvwr(SIE_padRingV18 *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void padRingV18_reset(SIE_padRingV18 *p);
     SIGN32 padRingV18_cmp  (SIE_padRingV18 *p, SIE_padRingV18 *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define padRingV18_check(p,pie,pfx,hLOG) padRingV18_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define padRingV18_print(p,    pfx,hLOG) padRingV18_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: padRingV18
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE HSpadRing                                (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  V12EN                     0x0
///                                    ###
///                                    * V12_EN=0 is for 1.8V normal mode, V12_EN=1 is to enable 1.2V high-speed mode.
///                                    * At 1.8V (V12_EN=0), DIO12OB pad performance is similar to DIOB.
///                                    ###
///               %unsigned 5  ZP                        0x1F
///                                    ###
///                                    * ZP[4:0] is used to program PMOS output driver strength for PAD18DIOB.
///                                    * 50 Ohm driver (lower speed ~100MHz)
///                                    * 01111: TYP CORNER
///                                    * 10101: SLOW CORNER
///                                    * 01011: FAST CORNER
///                                    * 33 Ohm driver (strong driver for high-speed ~200MHz)
///                                    * 10111: TYP CORNER
///                                    * 11111: SLOW CORNER
///                                    * 10000: FAST CORNER
///                                    ###
///               %unsigned 5  ZN                        0x1F
///                                    ###
///                                    * ZN[4:0] is used to program NMOS output driver strength for PAD18DIOB.
///                                    * 50 Ohm driver (lower speed ~100MHz)
///                                    * 01111: TYP CORNER
///                                    * 10101: SLOW CORNER
///                                    * 01011: FAST CORNER
///                                    * 33 Ohm driver (strong driver for high-speed ~200MHz)
///                                    * 10111: TYP CORNER
///                                    * 11111: SLOW CORNER
///                                    * 10000: FAST CORNER
///                                    ###
///               %%        21         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:      11b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_HSpadRing
#define h_HSpadRing (){}

    #define     RA_HSpadRing_ctrl                              0x0000

    #define     BA_HSpadRing_ctrl_V12EN                        0x0000
    #define     B16HSpadRing_ctrl_V12EN                        0x0000
    #define   LSb32HSpadRing_ctrl_V12EN                           0
    #define   LSb16HSpadRing_ctrl_V12EN                           0
    #define       bHSpadRing_ctrl_V12EN                        1
    #define   MSK32HSpadRing_ctrl_V12EN                           0x00000001

    #define     BA_HSpadRing_ctrl_ZP                           0x0000
    #define     B16HSpadRing_ctrl_ZP                           0x0000
    #define   LSb32HSpadRing_ctrl_ZP                              1
    #define   LSb16HSpadRing_ctrl_ZP                              1
    #define       bHSpadRing_ctrl_ZP                           5
    #define   MSK32HSpadRing_ctrl_ZP                              0x0000003E

    #define     BA_HSpadRing_ctrl_ZN                           0x0000
    #define     B16HSpadRing_ctrl_ZN                           0x0000
    #define   LSb32HSpadRing_ctrl_ZN                              6
    #define   LSb16HSpadRing_ctrl_ZN                              6
    #define       bHSpadRing_ctrl_ZN                           5
    #define   MSK32HSpadRing_ctrl_ZN                              0x000007C0
    ///////////////////////////////////////////////////////////

    typedef struct SIE_HSpadRing {
    ///////////////////////////////////////////////////////////
    #define   GET32HSpadRing_ctrl_V12EN(r32)                   _BFGET_(r32, 0, 0)
    #define   SET32HSpadRing_ctrl_V12EN(r32,v)                 _BFSET_(r32, 0, 0,v)
    #define   GET16HSpadRing_ctrl_V12EN(r16)                   _BFGET_(r16, 0, 0)
    #define   SET16HSpadRing_ctrl_V12EN(r16,v)                 _BFSET_(r16, 0, 0,v)

    #define   GET32HSpadRing_ctrl_ZP(r32)                      _BFGET_(r32, 5, 1)
    #define   SET32HSpadRing_ctrl_ZP(r32,v)                    _BFSET_(r32, 5, 1,v)
    #define   GET16HSpadRing_ctrl_ZP(r16)                      _BFGET_(r16, 5, 1)
    #define   SET16HSpadRing_ctrl_ZP(r16,v)                    _BFSET_(r16, 5, 1,v)

    #define   GET32HSpadRing_ctrl_ZN(r32)                      _BFGET_(r32,10, 6)
    #define   SET32HSpadRing_ctrl_ZN(r32,v)                    _BFSET_(r32,10, 6,v)
    #define   GET16HSpadRing_ctrl_ZN(r16)                      _BFGET_(r16,10, 6)
    #define   SET16HSpadRing_ctrl_ZN(r16,v)                    _BFSET_(r16,10, 6,v)

    #define     w32HSpadRing_ctrl                              {\
            UNSG32 uctrl_V12EN                                 :  1;\
            UNSG32 uctrl_ZP                                    :  5;\
            UNSG32 uctrl_ZN                                    :  5;\
            UNSG32 RSVDx0_b11                                  : 21;\
          }
    union { UNSG32 u32HSpadRing_ctrl;
            struct w32HSpadRing_ctrl;
          };
    ///////////////////////////////////////////////////////////
    } SIE_HSpadRing;

    typedef union  T32HSpadRing_ctrl
          { UNSG32 u32;
            struct w32HSpadRing_ctrl;
                 } T32HSpadRing_ctrl;
    ///////////////////////////////////////////////////////////

    typedef union  THSpadRing_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32HSpadRing_ctrl;
                   };
                 } THSpadRing_ctrl;

    ///////////////////////////////////////////////////////////
     SIGN32 HSpadRing_drvrd(SIE_HSpadRing *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 HSpadRing_drvwr(SIE_HSpadRing *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void HSpadRing_reset(SIE_HSpadRing *p);
     SIGN32 HSpadRing_cmp  (SIE_HSpadRing *p, SIE_HSpadRing *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define HSpadRing_check(p,pie,pfx,hLOG) HSpadRing_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define HSpadRing_print(p,    pfx,hLOG) HSpadRing_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: HSpadRing
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE FLpadRing                                (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  REG_PDB_CORE              0x0
///                                    ###
///                                    * Active low signal to place pads in power-down mode by driving ring signal LOW_VDDB_R = 0 PDB_CORE = 0, power-down
///                                    * PDB_CORE = 1, normal mode
///                                    ###
///               %unsigned 2  ODT_EN                    0x0
///                                    ###
///                                    * Active high, controls / enables the on-die termination for signal pads. Do Not Scan
///                                    * 00 - ODT off
///                                    * 01 - 150ohm ODT
///                                    * 10 - 75ohm ODT
///                                    * 11 - 50ohm ODT
///                                    ###
///               %unsigned 5  ZP                        0xF
///                                    ###
///                                    * Active high, controls the output driver pull-up network driving strength by selecting proper number of PMOS fingers to be turned on (All 0s = no fingers = tri-stated). Do Not Scan
///                                    ###
///               %unsigned 5  ZN                        0xF
///                                    ###
///                                    * Active high, controls the output driver pull-down network driving strength by selecting proper number of NMOS fingers to be turned on (All 0s = no fingers = tri-stated). Do Not Scan
///                                    ###
///               %%        19         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:      13b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_FLpadRing
#define h_FLpadRing (){}

    #define     RA_FLpadRing_ctrl                              0x0000

    #define     BA_FLpadRing_ctrl_REG_PDB_CORE                 0x0000
    #define     B16FLpadRing_ctrl_REG_PDB_CORE                 0x0000
    #define   LSb32FLpadRing_ctrl_REG_PDB_CORE                    0
    #define   LSb16FLpadRing_ctrl_REG_PDB_CORE                    0
    #define       bFLpadRing_ctrl_REG_PDB_CORE                 1
    #define   MSK32FLpadRing_ctrl_REG_PDB_CORE                    0x00000001

    #define     BA_FLpadRing_ctrl_ODT_EN                       0x0000
    #define     B16FLpadRing_ctrl_ODT_EN                       0x0000
    #define   LSb32FLpadRing_ctrl_ODT_EN                          1
    #define   LSb16FLpadRing_ctrl_ODT_EN                          1
    #define       bFLpadRing_ctrl_ODT_EN                       2
    #define   MSK32FLpadRing_ctrl_ODT_EN                          0x00000006

    #define     BA_FLpadRing_ctrl_ZP                           0x0000
    #define     B16FLpadRing_ctrl_ZP                           0x0000
    #define   LSb32FLpadRing_ctrl_ZP                              3
    #define   LSb16FLpadRing_ctrl_ZP                              3
    #define       bFLpadRing_ctrl_ZP                           5
    #define   MSK32FLpadRing_ctrl_ZP                              0x000000F8

    #define     BA_FLpadRing_ctrl_ZN                           0x0001
    #define     B16FLpadRing_ctrl_ZN                           0x0000
    #define   LSb32FLpadRing_ctrl_ZN                              8
    #define   LSb16FLpadRing_ctrl_ZN                              8
    #define       bFLpadRing_ctrl_ZN                           5
    #define   MSK32FLpadRing_ctrl_ZN                              0x00001F00
    ///////////////////////////////////////////////////////////

    typedef struct SIE_FLpadRing {
    ///////////////////////////////////////////////////////////
    #define   GET32FLpadRing_ctrl_REG_PDB_CORE(r32)            _BFGET_(r32, 0, 0)
    #define   SET32FLpadRing_ctrl_REG_PDB_CORE(r32,v)          _BFSET_(r32, 0, 0,v)
    #define   GET16FLpadRing_ctrl_REG_PDB_CORE(r16)            _BFGET_(r16, 0, 0)
    #define   SET16FLpadRing_ctrl_REG_PDB_CORE(r16,v)          _BFSET_(r16, 0, 0,v)

    #define   GET32FLpadRing_ctrl_ODT_EN(r32)                  _BFGET_(r32, 2, 1)
    #define   SET32FLpadRing_ctrl_ODT_EN(r32,v)                _BFSET_(r32, 2, 1,v)
    #define   GET16FLpadRing_ctrl_ODT_EN(r16)                  _BFGET_(r16, 2, 1)
    #define   SET16FLpadRing_ctrl_ODT_EN(r16,v)                _BFSET_(r16, 2, 1,v)

    #define   GET32FLpadRing_ctrl_ZP(r32)                      _BFGET_(r32, 7, 3)
    #define   SET32FLpadRing_ctrl_ZP(r32,v)                    _BFSET_(r32, 7, 3,v)
    #define   GET16FLpadRing_ctrl_ZP(r16)                      _BFGET_(r16, 7, 3)
    #define   SET16FLpadRing_ctrl_ZP(r16,v)                    _BFSET_(r16, 7, 3,v)

    #define   GET32FLpadRing_ctrl_ZN(r32)                      _BFGET_(r32,12, 8)
    #define   SET32FLpadRing_ctrl_ZN(r32,v)                    _BFSET_(r32,12, 8,v)
    #define   GET16FLpadRing_ctrl_ZN(r16)                      _BFGET_(r16,12, 8)
    #define   SET16FLpadRing_ctrl_ZN(r16,v)                    _BFSET_(r16,12, 8,v)

    #define     w32FLpadRing_ctrl                              {\
            UNSG32 uctrl_REG_PDB_CORE                          :  1;\
            UNSG32 uctrl_ODT_EN                                :  2;\
            UNSG32 uctrl_ZP                                    :  5;\
            UNSG32 uctrl_ZN                                    :  5;\
            UNSG32 RSVDx0_b13                                  : 19;\
          }
    union { UNSG32 u32FLpadRing_ctrl;
            struct w32FLpadRing_ctrl;
          };
    ///////////////////////////////////////////////////////////
    } SIE_FLpadRing;

    typedef union  T32FLpadRing_ctrl
          { UNSG32 u32;
            struct w32FLpadRing_ctrl;
                 } T32FLpadRing_ctrl;
    ///////////////////////////////////////////////////////////

    typedef union  TFLpadRing_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32FLpadRing_ctrl;
                   };
                 } TFLpadRing_ctrl;

    ///////////////////////////////////////////////////////////
     SIGN32 FLpadRing_drvrd(SIE_FLpadRing *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 FLpadRing_drvwr(SIE_FLpadRing *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void FLpadRing_reset(SIE_FLpadRing *p);
     SIGN32 FLpadRing_cmp  (SIE_FLpadRing *p, SIE_FLpadRing *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define FLpadRing_check(p,pie,pfx,hLOG) FLpadRing_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define FLpadRing_print(p,    pfx,hLOG) FLpadRing_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: FLpadRing
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE EMMC_PHY_PAD                             (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  PWRDN                     0x0
///                                    ###
///                                    * 0:Normal use
///                                    * 1: tristate pad and turn off termination
///                                    ###
///               %unsigned 1  PU                        0x0
///                                    ###
///                                    * 0: Disable Pullup for DQ
///                                    * 1: Enable Pullup for DQ
///                                    ###
///               %unsigned 1  PD                        0x0
///                                    ###
///                                    * 0: Disable Pulldown for DQ
///                                    * 1; Enable Pulldown for DQ
///                                    ###
///               %unsigned 1  RECEN                     0x1
///                                    ###
///                                    * 0:disable receiver for DQ
///                                    * 1: enable receiver for DQ
///                                    ###
///               %unsigned 1  RCVTYPE                   0x1
///                                    ###
///                                    * 0: differential receiver
///                                    * 1: CMOS receiver
///                                    ###
///               %%        27         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:       5b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_EMMC_PHY_PAD
#define h_EMMC_PHY_PAD (){}

    #define     RA_EMMC_PHY_PAD_ctrl                           0x0000

    #define     BA_EMMC_PHY_PAD_ctrl_PWRDN                     0x0000
    #define     B16EMMC_PHY_PAD_ctrl_PWRDN                     0x0000
    #define   LSb32EMMC_PHY_PAD_ctrl_PWRDN                        0
    #define   LSb16EMMC_PHY_PAD_ctrl_PWRDN                        0
    #define       bEMMC_PHY_PAD_ctrl_PWRDN                     1
    #define   MSK32EMMC_PHY_PAD_ctrl_PWRDN                        0x00000001

    #define     BA_EMMC_PHY_PAD_ctrl_PU                        0x0000
    #define     B16EMMC_PHY_PAD_ctrl_PU                        0x0000
    #define   LSb32EMMC_PHY_PAD_ctrl_PU                           1
    #define   LSb16EMMC_PHY_PAD_ctrl_PU                           1
    #define       bEMMC_PHY_PAD_ctrl_PU                        1
    #define   MSK32EMMC_PHY_PAD_ctrl_PU                           0x00000002

    #define     BA_EMMC_PHY_PAD_ctrl_PD                        0x0000
    #define     B16EMMC_PHY_PAD_ctrl_PD                        0x0000
    #define   LSb32EMMC_PHY_PAD_ctrl_PD                           2
    #define   LSb16EMMC_PHY_PAD_ctrl_PD                           2
    #define       bEMMC_PHY_PAD_ctrl_PD                        1
    #define   MSK32EMMC_PHY_PAD_ctrl_PD                           0x00000004

    #define     BA_EMMC_PHY_PAD_ctrl_RECEN                     0x0000
    #define     B16EMMC_PHY_PAD_ctrl_RECEN                     0x0000
    #define   LSb32EMMC_PHY_PAD_ctrl_RECEN                        3
    #define   LSb16EMMC_PHY_PAD_ctrl_RECEN                        3
    #define       bEMMC_PHY_PAD_ctrl_RECEN                     1
    #define   MSK32EMMC_PHY_PAD_ctrl_RECEN                        0x00000008

    #define     BA_EMMC_PHY_PAD_ctrl_RCVTYPE                   0x0000
    #define     B16EMMC_PHY_PAD_ctrl_RCVTYPE                   0x0000
    #define   LSb32EMMC_PHY_PAD_ctrl_RCVTYPE                      4
    #define   LSb16EMMC_PHY_PAD_ctrl_RCVTYPE                      4
    #define       bEMMC_PHY_PAD_ctrl_RCVTYPE                   1
    #define   MSK32EMMC_PHY_PAD_ctrl_RCVTYPE                      0x00000010
    ///////////////////////////////////////////////////////////

    typedef struct SIE_EMMC_PHY_PAD {
    ///////////////////////////////////////////////////////////
    #define   GET32EMMC_PHY_PAD_ctrl_PWRDN(r32)                _BFGET_(r32, 0, 0)
    #define   SET32EMMC_PHY_PAD_ctrl_PWRDN(r32,v)              _BFSET_(r32, 0, 0,v)
    #define   GET16EMMC_PHY_PAD_ctrl_PWRDN(r16)                _BFGET_(r16, 0, 0)
    #define   SET16EMMC_PHY_PAD_ctrl_PWRDN(r16,v)              _BFSET_(r16, 0, 0,v)

    #define   GET32EMMC_PHY_PAD_ctrl_PU(r32)                   _BFGET_(r32, 1, 1)
    #define   SET32EMMC_PHY_PAD_ctrl_PU(r32,v)                 _BFSET_(r32, 1, 1,v)
    #define   GET16EMMC_PHY_PAD_ctrl_PU(r16)                   _BFGET_(r16, 1, 1)
    #define   SET16EMMC_PHY_PAD_ctrl_PU(r16,v)                 _BFSET_(r16, 1, 1,v)

    #define   GET32EMMC_PHY_PAD_ctrl_PD(r32)                   _BFGET_(r32, 2, 2)
    #define   SET32EMMC_PHY_PAD_ctrl_PD(r32,v)                 _BFSET_(r32, 2, 2,v)
    #define   GET16EMMC_PHY_PAD_ctrl_PD(r16)                   _BFGET_(r16, 2, 2)
    #define   SET16EMMC_PHY_PAD_ctrl_PD(r16,v)                 _BFSET_(r16, 2, 2,v)

    #define   GET32EMMC_PHY_PAD_ctrl_RECEN(r32)                _BFGET_(r32, 3, 3)
    #define   SET32EMMC_PHY_PAD_ctrl_RECEN(r32,v)              _BFSET_(r32, 3, 3,v)
    #define   GET16EMMC_PHY_PAD_ctrl_RECEN(r16)                _BFGET_(r16, 3, 3)
    #define   SET16EMMC_PHY_PAD_ctrl_RECEN(r16,v)              _BFSET_(r16, 3, 3,v)

    #define   GET32EMMC_PHY_PAD_ctrl_RCVTYPE(r32)              _BFGET_(r32, 4, 4)
    #define   SET32EMMC_PHY_PAD_ctrl_RCVTYPE(r32,v)            _BFSET_(r32, 4, 4,v)
    #define   GET16EMMC_PHY_PAD_ctrl_RCVTYPE(r16)              _BFGET_(r16, 4, 4)
    #define   SET16EMMC_PHY_PAD_ctrl_RCVTYPE(r16,v)            _BFSET_(r16, 4, 4,v)

    #define     w32EMMC_PHY_PAD_ctrl                           {\
            UNSG32 uctrl_PWRDN                                 :  1;\
            UNSG32 uctrl_PU                                    :  1;\
            UNSG32 uctrl_PD                                    :  1;\
            UNSG32 uctrl_RECEN                                 :  1;\
            UNSG32 uctrl_RCVTYPE                               :  1;\
            UNSG32 RSVDx0_b5                                   : 27;\
          }
    union { UNSG32 u32EMMC_PHY_PAD_ctrl;
            struct w32EMMC_PHY_PAD_ctrl;
          };
    ///////////////////////////////////////////////////////////
    } SIE_EMMC_PHY_PAD;

    typedef union  T32EMMC_PHY_PAD_ctrl
          { UNSG32 u32;
            struct w32EMMC_PHY_PAD_ctrl;
                 } T32EMMC_PHY_PAD_ctrl;
    ///////////////////////////////////////////////////////////

    typedef union  TEMMC_PHY_PAD_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32EMMC_PHY_PAD_ctrl;
                   };
                 } TEMMC_PHY_PAD_ctrl;

    ///////////////////////////////////////////////////////////
     SIGN32 EMMC_PHY_PAD_drvrd(SIE_EMMC_PHY_PAD *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 EMMC_PHY_PAD_drvwr(SIE_EMMC_PHY_PAD *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void EMMC_PHY_PAD_reset(SIE_EMMC_PHY_PAD *p);
     SIGN32 EMMC_PHY_PAD_cmp  (SIE_EMMC_PHY_PAD *p, SIE_EMMC_PHY_PAD *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define EMMC_PHY_PAD_check(p,pie,pfx,hLOG) EMMC_PHY_PAD_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define EMMC_PHY_PAD_print(p,    pfx,hLOG) EMMC_PHY_PAD_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: EMMC_PHY_PAD
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE EMMC_DRVCNTL                             (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  ODT_SEL0                  0x0
///                                    ###
///                                    * On Die Termination
///                                    ###
///               %unsigned 1  ODT_SEL1                  0x0
///                                    ###
///                                    * On Die Termination
///                                    ###
///               %unsigned 5  ZPR                       0x1F
///                                    ###
///                                    * P Driver Per-finger drive strength. Controls the P-side output drive strength.
///                                    ###
///               %unsigned 5  ZNR                       0x1F
///                                    ###
///                                    * N Driver Per-finger drive strenth. Controls the N-side output drive strength.
///                                    ###
///               %unsigned 1  ZD                        0x1
///                                    ###
///                                    * Reserved
///                                    ###
///               %%        19         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:      13b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_EMMC_DRVCNTL
#define h_EMMC_DRVCNTL (){}

    #define     RA_EMMC_DRVCNTL_ctrl                           0x0000

    #define     BA_EMMC_DRVCNTL_ctrl_ODT_SEL0                  0x0000
    #define     B16EMMC_DRVCNTL_ctrl_ODT_SEL0                  0x0000
    #define   LSb32EMMC_DRVCNTL_ctrl_ODT_SEL0                     0
    #define   LSb16EMMC_DRVCNTL_ctrl_ODT_SEL0                     0
    #define       bEMMC_DRVCNTL_ctrl_ODT_SEL0                  1
    #define   MSK32EMMC_DRVCNTL_ctrl_ODT_SEL0                     0x00000001

    #define     BA_EMMC_DRVCNTL_ctrl_ODT_SEL1                  0x0000
    #define     B16EMMC_DRVCNTL_ctrl_ODT_SEL1                  0x0000
    #define   LSb32EMMC_DRVCNTL_ctrl_ODT_SEL1                     1
    #define   LSb16EMMC_DRVCNTL_ctrl_ODT_SEL1                     1
    #define       bEMMC_DRVCNTL_ctrl_ODT_SEL1                  1
    #define   MSK32EMMC_DRVCNTL_ctrl_ODT_SEL1                     0x00000002

    #define     BA_EMMC_DRVCNTL_ctrl_ZPR                       0x0000
    #define     B16EMMC_DRVCNTL_ctrl_ZPR                       0x0000
    #define   LSb32EMMC_DRVCNTL_ctrl_ZPR                          2
    #define   LSb16EMMC_DRVCNTL_ctrl_ZPR                          2
    #define       bEMMC_DRVCNTL_ctrl_ZPR                       5
    #define   MSK32EMMC_DRVCNTL_ctrl_ZPR                          0x0000007C

    #define     BA_EMMC_DRVCNTL_ctrl_ZNR                       0x0000
    #define     B16EMMC_DRVCNTL_ctrl_ZNR                       0x0000
    #define   LSb32EMMC_DRVCNTL_ctrl_ZNR                          7
    #define   LSb16EMMC_DRVCNTL_ctrl_ZNR                          7
    #define       bEMMC_DRVCNTL_ctrl_ZNR                       5
    #define   MSK32EMMC_DRVCNTL_ctrl_ZNR                          0x00000F80

    #define     BA_EMMC_DRVCNTL_ctrl_ZD                        0x0001
    #define     B16EMMC_DRVCNTL_ctrl_ZD                        0x0000
    #define   LSb32EMMC_DRVCNTL_ctrl_ZD                           12
    #define   LSb16EMMC_DRVCNTL_ctrl_ZD                           12
    #define       bEMMC_DRVCNTL_ctrl_ZD                        1
    #define   MSK32EMMC_DRVCNTL_ctrl_ZD                           0x00001000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_EMMC_DRVCNTL {
    ///////////////////////////////////////////////////////////
    #define   GET32EMMC_DRVCNTL_ctrl_ODT_SEL0(r32)             _BFGET_(r32, 0, 0)
    #define   SET32EMMC_DRVCNTL_ctrl_ODT_SEL0(r32,v)           _BFSET_(r32, 0, 0,v)
    #define   GET16EMMC_DRVCNTL_ctrl_ODT_SEL0(r16)             _BFGET_(r16, 0, 0)
    #define   SET16EMMC_DRVCNTL_ctrl_ODT_SEL0(r16,v)           _BFSET_(r16, 0, 0,v)

    #define   GET32EMMC_DRVCNTL_ctrl_ODT_SEL1(r32)             _BFGET_(r32, 1, 1)
    #define   SET32EMMC_DRVCNTL_ctrl_ODT_SEL1(r32,v)           _BFSET_(r32, 1, 1,v)
    #define   GET16EMMC_DRVCNTL_ctrl_ODT_SEL1(r16)             _BFGET_(r16, 1, 1)
    #define   SET16EMMC_DRVCNTL_ctrl_ODT_SEL1(r16,v)           _BFSET_(r16, 1, 1,v)

    #define   GET32EMMC_DRVCNTL_ctrl_ZPR(r32)                  _BFGET_(r32, 6, 2)
    #define   SET32EMMC_DRVCNTL_ctrl_ZPR(r32,v)                _BFSET_(r32, 6, 2,v)
    #define   GET16EMMC_DRVCNTL_ctrl_ZPR(r16)                  _BFGET_(r16, 6, 2)
    #define   SET16EMMC_DRVCNTL_ctrl_ZPR(r16,v)                _BFSET_(r16, 6, 2,v)

    #define   GET32EMMC_DRVCNTL_ctrl_ZNR(r32)                  _BFGET_(r32,11, 7)
    #define   SET32EMMC_DRVCNTL_ctrl_ZNR(r32,v)                _BFSET_(r32,11, 7,v)
    #define   GET16EMMC_DRVCNTL_ctrl_ZNR(r16)                  _BFGET_(r16,11, 7)
    #define   SET16EMMC_DRVCNTL_ctrl_ZNR(r16,v)                _BFSET_(r16,11, 7,v)

    #define   GET32EMMC_DRVCNTL_ctrl_ZD(r32)                   _BFGET_(r32,12,12)
    #define   SET32EMMC_DRVCNTL_ctrl_ZD(r32,v)                 _BFSET_(r32,12,12,v)
    #define   GET16EMMC_DRVCNTL_ctrl_ZD(r16)                   _BFGET_(r16,12,12)
    #define   SET16EMMC_DRVCNTL_ctrl_ZD(r16,v)                 _BFSET_(r16,12,12,v)

    #define     w32EMMC_DRVCNTL_ctrl                           {\
            UNSG32 uctrl_ODT_SEL0                              :  1;\
            UNSG32 uctrl_ODT_SEL1                              :  1;\
            UNSG32 uctrl_ZPR                                   :  5;\
            UNSG32 uctrl_ZNR                                   :  5;\
            UNSG32 uctrl_ZD                                    :  1;\
            UNSG32 RSVDx0_b13                                  : 19;\
          }
    union { UNSG32 u32EMMC_DRVCNTL_ctrl;
            struct w32EMMC_DRVCNTL_ctrl;
          };
    ///////////////////////////////////////////////////////////
    } SIE_EMMC_DRVCNTL;

    typedef union  T32EMMC_DRVCNTL_ctrl
          { UNSG32 u32;
            struct w32EMMC_DRVCNTL_ctrl;
                 } T32EMMC_DRVCNTL_ctrl;
    ///////////////////////////////////////////////////////////

    typedef union  TEMMC_DRVCNTL_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32EMMC_DRVCNTL_ctrl;
                   };
                 } TEMMC_DRVCNTL_ctrl;

    ///////////////////////////////////////////////////////////
     SIGN32 EMMC_DRVCNTL_drvrd(SIE_EMMC_DRVCNTL *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 EMMC_DRVCNTL_drvwr(SIE_EMMC_DRVCNTL *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void EMMC_DRVCNTL_reset(SIE_EMMC_DRVCNTL *p);
     SIGN32 EMMC_DRVCNTL_cmp  (SIE_EMMC_DRVCNTL *p, SIE_EMMC_DRVCNTL *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define EMMC_DRVCNTL_check(p,pie,pfx,hLOG) EMMC_DRVCNTL_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define EMMC_DRVCNTL_print(p,    pfx,hLOG) EMMC_DRVCNTL_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: EMMC_DRVCNTL
////////////////////////////////////////////////////////////

//////
/// 
/// $INTERFACE EMMCS28_PAD                              (4,4)
///     # # ----------------------------------------------------------
///     @ 0x00000 ctrl                 (P-)
///               %unsigned 1  REG_PDB_CORE              0x1
///                                    ###
///                                    * 0: PWRDN
///                                    * 1: NORMAL
///                                    * When REG_PDB_CORE is logic “1”, the regulator works in normal mode and consumes ~60uA current at typical 25degC. When REG_PDB_CORE is logic “0”, the regulator works in power-down mode and consumes ~6uA current at typical 25degC.
///                                    ###
///               %unsigned 1  V18EN_CORE                0x0
///               %unsigned 1  V25EN_CORE                0x0
///                                    ###
///                                    * V18EN_CORE and V25EN_CORE are settings for different IO supply level.
///                                    * V18EN_CORE=0, V25EN-CORE=0: 3.3V
///                                    * V18EN_CORE=0,V25EN_CORE=1: 2.5V
///                                    * V18EN_CORE=1,V25EN_CORE=X: 1.5V, 1.5V or 1.8V.
///                                    ###
///               %unsigned 5  ZP                        0x1F
///                                    ###
///                                    * ZP[3:0] is used to program PMOS output driver strength for PADXDC_HSIOB.
///                                    * ZP[3:0] = “1111” is the strongest setting.
///                                    ###
///               %unsigned 5  ZN                        0x1F
///                                    ###
///                                    * ZN[3:0] is used to program NMOS output driver strength for PADXDC_HSIOB.
///                                    * ZN[3:0] = “1111” is the strongest setting.
///                                    ###
///               %unsigned 1  PDB_CORE                  0x1
///                                    ###
///                                    * Active low signal to place pads in power-down mode by driving ring signal LOW_VDDB_R=0;
///                                    * 0: power-down
///                                    * 1: normal mode
///                                    * This signal is not to be mistaken with REG_PDB_CORE. REG_PDB_CORE is to power-down the regulator and make all signal pads tristated.
///                                    ###
///               %%        18         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:      14b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_EMMCS28_PAD
#define h_EMMCS28_PAD (){}

    #define     RA_EMMCS28_PAD_ctrl                            0x0000

    #define     BA_EMMCS28_PAD_ctrl_REG_PDB_CORE               0x0000
    #define     B16EMMCS28_PAD_ctrl_REG_PDB_CORE               0x0000
    #define   LSb32EMMCS28_PAD_ctrl_REG_PDB_CORE                  0
    #define   LSb16EMMCS28_PAD_ctrl_REG_PDB_CORE                  0
    #define       bEMMCS28_PAD_ctrl_REG_PDB_CORE               1
    #define   MSK32EMMCS28_PAD_ctrl_REG_PDB_CORE                  0x00000001

    #define     BA_EMMCS28_PAD_ctrl_V18EN_CORE                 0x0000
    #define     B16EMMCS28_PAD_ctrl_V18EN_CORE                 0x0000
    #define   LSb32EMMCS28_PAD_ctrl_V18EN_CORE                    1
    #define   LSb16EMMCS28_PAD_ctrl_V18EN_CORE                    1
    #define       bEMMCS28_PAD_ctrl_V18EN_CORE                 1
    #define   MSK32EMMCS28_PAD_ctrl_V18EN_CORE                    0x00000002

    #define     BA_EMMCS28_PAD_ctrl_V25EN_CORE                 0x0000
    #define     B16EMMCS28_PAD_ctrl_V25EN_CORE                 0x0000
    #define   LSb32EMMCS28_PAD_ctrl_V25EN_CORE                    2
    #define   LSb16EMMCS28_PAD_ctrl_V25EN_CORE                    2
    #define       bEMMCS28_PAD_ctrl_V25EN_CORE                 1
    #define   MSK32EMMCS28_PAD_ctrl_V25EN_CORE                    0x00000004

    #define     BA_EMMCS28_PAD_ctrl_ZP                         0x0000
    #define     B16EMMCS28_PAD_ctrl_ZP                         0x0000
    #define   LSb32EMMCS28_PAD_ctrl_ZP                            3
    #define   LSb16EMMCS28_PAD_ctrl_ZP                            3
    #define       bEMMCS28_PAD_ctrl_ZP                         5
    #define   MSK32EMMCS28_PAD_ctrl_ZP                            0x000000F8

    #define     BA_EMMCS28_PAD_ctrl_ZN                         0x0001
    #define     B16EMMCS28_PAD_ctrl_ZN                         0x0000
    #define   LSb32EMMCS28_PAD_ctrl_ZN                            8
    #define   LSb16EMMCS28_PAD_ctrl_ZN                            8
    #define       bEMMCS28_PAD_ctrl_ZN                         5
    #define   MSK32EMMCS28_PAD_ctrl_ZN                            0x00001F00

    #define     BA_EMMCS28_PAD_ctrl_PDB_CORE                   0x0001
    #define     B16EMMCS28_PAD_ctrl_PDB_CORE                   0x0000
    #define   LSb32EMMCS28_PAD_ctrl_PDB_CORE                      13
    #define   LSb16EMMCS28_PAD_ctrl_PDB_CORE                      13
    #define       bEMMCS28_PAD_ctrl_PDB_CORE                   1
    #define   MSK32EMMCS28_PAD_ctrl_PDB_CORE                      0x00002000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_EMMCS28_PAD {
    ///////////////////////////////////////////////////////////
    #define   GET32EMMCS28_PAD_ctrl_REG_PDB_CORE(r32)          _BFGET_(r32, 0, 0)
    #define   SET32EMMCS28_PAD_ctrl_REG_PDB_CORE(r32,v)        _BFSET_(r32, 0, 0,v)
    #define   GET16EMMCS28_PAD_ctrl_REG_PDB_CORE(r16)          _BFGET_(r16, 0, 0)
    #define   SET16EMMCS28_PAD_ctrl_REG_PDB_CORE(r16,v)        _BFSET_(r16, 0, 0,v)

    #define   GET32EMMCS28_PAD_ctrl_V18EN_CORE(r32)            _BFGET_(r32, 1, 1)
    #define   SET32EMMCS28_PAD_ctrl_V18EN_CORE(r32,v)          _BFSET_(r32, 1, 1,v)
    #define   GET16EMMCS28_PAD_ctrl_V18EN_CORE(r16)            _BFGET_(r16, 1, 1)
    #define   SET16EMMCS28_PAD_ctrl_V18EN_CORE(r16,v)          _BFSET_(r16, 1, 1,v)

    #define   GET32EMMCS28_PAD_ctrl_V25EN_CORE(r32)            _BFGET_(r32, 2, 2)
    #define   SET32EMMCS28_PAD_ctrl_V25EN_CORE(r32,v)          _BFSET_(r32, 2, 2,v)
    #define   GET16EMMCS28_PAD_ctrl_V25EN_CORE(r16)            _BFGET_(r16, 2, 2)
    #define   SET16EMMCS28_PAD_ctrl_V25EN_CORE(r16,v)          _BFSET_(r16, 2, 2,v)

    #define   GET32EMMCS28_PAD_ctrl_ZP(r32)                    _BFGET_(r32, 7, 3)
    #define   SET32EMMCS28_PAD_ctrl_ZP(r32,v)                  _BFSET_(r32, 7, 3,v)
    #define   GET16EMMCS28_PAD_ctrl_ZP(r16)                    _BFGET_(r16, 7, 3)
    #define   SET16EMMCS28_PAD_ctrl_ZP(r16,v)                  _BFSET_(r16, 7, 3,v)

    #define   GET32EMMCS28_PAD_ctrl_ZN(r32)                    _BFGET_(r32,12, 8)
    #define   SET32EMMCS28_PAD_ctrl_ZN(r32,v)                  _BFSET_(r32,12, 8,v)
    #define   GET16EMMCS28_PAD_ctrl_ZN(r16)                    _BFGET_(r16,12, 8)
    #define   SET16EMMCS28_PAD_ctrl_ZN(r16,v)                  _BFSET_(r16,12, 8,v)

    #define   GET32EMMCS28_PAD_ctrl_PDB_CORE(r32)              _BFGET_(r32,13,13)
    #define   SET32EMMCS28_PAD_ctrl_PDB_CORE(r32,v)            _BFSET_(r32,13,13,v)
    #define   GET16EMMCS28_PAD_ctrl_PDB_CORE(r16)              _BFGET_(r16,13,13)
    #define   SET16EMMCS28_PAD_ctrl_PDB_CORE(r16,v)            _BFSET_(r16,13,13,v)

    #define     w32EMMCS28_PAD_ctrl                            {\
            UNSG32 uctrl_REG_PDB_CORE                          :  1;\
            UNSG32 uctrl_V18EN_CORE                            :  1;\
            UNSG32 uctrl_V25EN_CORE                            :  1;\
            UNSG32 uctrl_ZP                                    :  5;\
            UNSG32 uctrl_ZN                                    :  5;\
            UNSG32 uctrl_PDB_CORE                              :  1;\
            UNSG32 RSVDx0_b14                                  : 18;\
          }
    union { UNSG32 u32EMMCS28_PAD_ctrl;
            struct w32EMMCS28_PAD_ctrl;
          };
    ///////////////////////////////////////////////////////////
    } SIE_EMMCS28_PAD;

    typedef union  T32EMMCS28_PAD_ctrl
          { UNSG32 u32;
            struct w32EMMCS28_PAD_ctrl;
                 } T32EMMCS28_PAD_ctrl;
    ///////////////////////////////////////////////////////////

    typedef union  TEMMCS28_PAD_ctrl
          { UNSG32 u32[1];
            struct {
            struct w32EMMCS28_PAD_ctrl;
                   };
                 } TEMMCS28_PAD_ctrl;

    ///////////////////////////////////////////////////////////
     SIGN32 EMMCS28_PAD_drvrd(SIE_EMMCS28_PAD *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 EMMCS28_PAD_drvwr(SIE_EMMCS28_PAD *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void EMMCS28_PAD_reset(SIE_EMMCS28_PAD *p);
     SIGN32 EMMCS28_PAD_cmp  (SIE_EMMCS28_PAD *p, SIE_EMMCS28_PAD *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define EMMCS28_PAD_check(p,pie,pfx,hLOG) EMMCS28_PAD_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define EMMCS28_PAD_print(p,    pfx,hLOG) EMMCS28_PAD_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: EMMCS28_PAD
////////////////////////////////////////////////////////////



#ifdef __cplusplus
  }
#endif
#pragma  pack()

#endif
//////
/// ENDOFFILE: padRing.h
////////////////////////////////////////////////////////////

