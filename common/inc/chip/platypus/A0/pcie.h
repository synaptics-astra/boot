//////
/// don't edit! auto-generated by docc: pcie.h
////////////////////////////////////////////////////////////
#ifndef pcie_h
#define pcie_h (){}


#include "ctypes.h"

#pragma pack(1)
#ifdef __cplusplus
  extern "C" {
#endif

#ifndef _DOCC_H_BITOPS_
#define _DOCC_H_BITOPS_ (){}

    #define _bSETMASK_(b)                                      ((b)<32 ? (1<<((b)&31)) : 0)
    #define _NSETMASK_(msb,lsb)                                (_bSETMASK_((msb)+1)-_bSETMASK_(lsb))
    #define _bCLRMASK_(b)                                      (~_bSETMASK_(b))
    #define _NCLRMASK_(msb,lsb)                                (~_NSETMASK_(msb,lsb))
    #define _BFGET_(r,msb,lsb)                                 (_NSETMASK_((msb)-(lsb),0)&((r)>>(lsb)))
    #define _BFSET_(r,msb,lsb,v)                               do{ (r)&=_NCLRMASK_(msb,lsb); (r)|=_NSETMASK_(msb,lsb)&((v)<<(lsb)); }while(0)

#endif



//////
///
/// $INTERFACE oneReg                                   (4,4)
///     ###
///     * To create SRAM-like interface creating one 32-bit register (Hier:1)
///     ###
///     # # ----------------------------------------------------------
///     @ 0x00000                      (R-)
///               %unsigned 32 0x00000000
///                                    ###
///                                    * One Register in an external IP block (i.e., PEX)
///                                    ###
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:       4B, bits:      32b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_oneReg
#define h_oneReg (){}

    #define     BA_oneReg_0x00000000                           0x0000
    #define     B16oneReg_0x00000000                           0x0000
    #define   LSb32oneReg_0x00000000                              0
    #define   LSb16oneReg_0x00000000                              0
    #define       boneReg_0x00000000                           32
    #define   MSK32oneReg_0x00000000                              0xFFFFFFFF
    ///////////////////////////////////////////////////////////

    typedef struct SIE_oneReg {
    ///////////////////////////////////////////////////////////
    #define   GET32oneReg_0x00000000(r32)                      _BFGET_(r32,31, 0)
    #define   SET32oneReg_0x00000000(r32,v)                    _BFSET_(r32,31, 0,v)

            UNSG32 u_0x00000000                                : 32;
    ///////////////////////////////////////////////////////////
    } SIE_oneReg;

    ///////////////////////////////////////////////////////////
     SIGN32 oneReg_drvrd(SIE_oneReg *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 oneReg_drvwr(SIE_oneReg *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void oneReg_reset(SIE_oneReg *p);
     SIGN32 oneReg_cmp  (SIE_oneReg *p, SIE_oneReg *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define oneReg_check(p,pie,pfx,hLOG) oneReg_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define oneReg_print(p,    pfx,hLOG) oneReg_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: oneReg
////////////////////////////////////////////////////////////

//////
///
/// $INTERFACE IP_REGSP_0                               (4,4)
///     ###
///     * To create SRAM-like interface for PCI-E 3 IP Register access – Creating 32KB address space (Hier:2)
///     ###
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy
///               $oneReg              dummy             REG    [8192]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:   32768B, bits:  262144b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_IP_REGSP_0
#define h_IP_REGSP_0 (){}

    #define     RA_IP_REGSP_0_dummy                            0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_IP_REGSP_0 {
    ///////////////////////////////////////////////////////////
              SIE_oneReg                                       ie_dummy[8192];
    ///////////////////////////////////////////////////////////
    } SIE_IP_REGSP_0;

    ///////////////////////////////////////////////////////////
     SIGN32 IP_REGSP_0_drvrd(SIE_IP_REGSP_0 *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 IP_REGSP_0_drvwr(SIE_IP_REGSP_0 *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void IP_REGSP_0_reset(SIE_IP_REGSP_0 *p);
     SIGN32 IP_REGSP_0_cmp  (SIE_IP_REGSP_0 *p, SIE_IP_REGSP_0 *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define IP_REGSP_0_check(p,pie,pfx,hLOG) IP_REGSP_0_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define IP_REGSP_0_print(p,    pfx,hLOG) IP_REGSP_0_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: IP_REGSP_0
////////////////////////////////////////////////////////////

//////
///
/// $INTERFACE IP_REGSP_1                               (4,4)
///     ###
///     * To create SRAM-like interface for PCI-E 3 IP Register access – creating 4KB address space. (Hier:2)
///     ###
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 dummy
///               $oneReg              dummy             REG    [2048]
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:    8192B, bits:   65536b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_IP_REGSP_1
#define h_IP_REGSP_1 (){}

    #define     RA_IP_REGSP_1_dummy                            0x0000
    ///////////////////////////////////////////////////////////

    typedef struct SIE_IP_REGSP_1 {
    ///////////////////////////////////////////////////////////
              SIE_oneReg                                       ie_dummy[2048];
    ///////////////////////////////////////////////////////////
    } SIE_IP_REGSP_1;

    ///////////////////////////////////////////////////////////
     SIGN32 IP_REGSP_1_drvrd(SIE_IP_REGSP_1 *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 IP_REGSP_1_drvwr(SIE_IP_REGSP_1 *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void IP_REGSP_1_reset(SIE_IP_REGSP_1 *p);
     SIGN32 IP_REGSP_1_cmp  (SIE_IP_REGSP_1 *p, SIE_IP_REGSP_1 *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define IP_REGSP_1_check(p,pie,pfx,hLOG) IP_REGSP_1_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define IP_REGSP_1_print(p,    pfx,hLOG) IP_REGSP_1_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: IP_REGSP_1
////////////////////////////////////////////////////////////

//////
///
/// $INTERFACE REFCLK                                   (4,4)
///     ###
///     * PCI-E reference clock buffer control register. This buffer can act in both RX and TX mode.
///     * In RX mode: This buffer takes in 100 Mhz differential clock and generates the single ended 100 Mhz Clock for PCI-E PHY
///     * In TX mode: This buffer receives the single ended 100 Mhz clock from PCIE PLL and sends out the differential 100 Mhz clock to Pad
///     ###
///     # # ----------------------------------------------------------
///     @ 0x00000 CTRL                 (RW)
///               %unsigned 2  CLK_SEL                   0x0
///                                    ###
///                                    * Selects one of the 4 Input clocks to be output on PAD
///                                    * 00 : CLKIN0
///                                    * 01 : CLKIN1
///                                    * 10 : CLKIN2
///                                    * 11 : CLKIN3
///                                    ###
///               %unsigned 1  PULL_DOWN                 0x0
///                                    ###
///                                    * Software control for Pull Down and TX_EN for reference clock buffer when operating in RX mode
///                                    * 0 : No Internal Pull Down
///                                    * 1:   Pull Down enabled. This forces the Buffer to RX Mode as well.
///                                    ###
///               %unsigned 1  TX_EN                     0x0
///                                    ###
///                                    * Selects the buffer in Transmit or Receive mode
///                                    * 0: Receive Mode
///                                    * 1: Transmit Mode
///                                    ###
///               %unsigned 5  IMP_CTRL                  0x3
///                                    ###
///                                    * Driver Impedance control.
///                                    * 0-7: 50.7 to 32.9Ohms range in FF
///                                    * 0-7: 61.3 to 39.8Ohms range in TT
///                                    * 0-7: 75.1 to 45.6Ohms range in SS
///                                    ###
///               %unsigned 1  DE_EMP_EN                 0x0
///                                    ###
///                                    * De Emphasis Enable
///                                    * 0 : No De Emphasis (100% Swing)
///                                    * 1: De Emphasis Enable
///                                    ###
///               %unsigned 3  DE_EMP                    0x0
///                                    ###
///                                    * De Emphasis value for REFCLK Buffer. This also Depends on IMP_CTRL.
///                                    * With IMP_CTRL = 3 following are the values
///                                    * 0: 50%
///                                    * 1: 63%
///                                    * 2: 75%
///                                    * 3: 88%
///                                    ###
///               %unsigned 1  USE_INPUT_CLK             0x0
///                                    ###
///                                    * Set TX_EN to 0, and use the input clock as reference for PCIe PHY by setting this bit to 1
///                                    ###
///               %%        18         # Stuffing bits...
///     @ 0x00004 PLL_CTRL             (RW)
///               ###
///               * PCIe PLL control register to control PLL ports
///               ###
///               %unsigned 1  RESET                     0x1
///                                    ###
///                                    * PLL Internal Reset. Acts as power down to analog circuit
///                                    * 0: Normal Operation
///                                    * 1: Power Down
///                                    ###
///               %unsigned 1  BYPASS                    0x0
///                                    ###
///                                    * PLL Bypass Enable
///                                    * 0: Normal Operation
///                                    * 1: Bypass, REFCLK will be output on PLLOUT
///                                    ###
///               %unsigned 3  SSMD                      0x0
///                                    ###
///                                    * Spread Spectrum Modulation depth control
///                                    * 0: SSC OFF
///                                    * 1: Spread of 50ppm
///                                    * 2: Spread of 100ppm
///                                    * 3: Spread of 250ppm
///                                    * 4: Spread of 500ppm
///                                    * 5: Spread of 1000ppm
///                                    * 6: Spread of 2300ppm
///                                    * 7: Spread of 5000ppm
///                                    ###
///               %unsigned 1  SSDS                      0x1
///                                    ###
///                                    * Spread spectrum selection
///                                    * 0: Center Spread
///                                    * 1: Down Spread
///                                    ###
///               %unsigned 1  SSFIN100                  0x0
///                                    ###
///                                    * Selects between 25MHz and 100MHz input frequencies
///                                    * 0: 25MHz input
///                                    * 1: 100MHz input
///                                    ###
///               %unsigned 1  SSFOUT100                 0x1
///                                    ###
///                                    * PLL Output Frequency of 100MHz selected
///                                    * 0: 100MHz un-selected
///                                    * 1: 100MHz selected
///                                    ###
///               %unsigned 1  SSFOUT125                 0x0
///                                    ###
///                                    * PLL Output Frequency of 125MHz selected
///                                    * 0: 125MHz un-selected
///                                    * 1: 125MHz selected
///                                    ###
///               %unsigned 1  SSFOUT250                 0x0
///                                    ###
///                                    * PLL Output Frequency of 250MHz selected
///                                    * 0: 250MHz un-selected
///                                    * 1: 250MHz selected
///                                    ###
///               %unsigned 1  SSFOUT500                 0x0
///                                    ###
///                                    * PLL Output Frequency of 500MHz selected
///                                    * 0: 500MHz un-selected
///                                    * 1: 500MHz selected
///                                    ###
///               %unsigned 4  SSICP                     0x0
///                                    ###
///                                    * Loop BW control.
///                                    ###
///               %%        17         # Stuffing bits...
///     @ 0x00008 PLL_STATUS           (R-)
///               ###
///               * PCIe PLL status register
///               ###
///               %unsigned 1  LOCK
///                                    ###
///                                    * PLL lock output for monitoring
///                                    ###
///               %%        31         # Stuffing bits...
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:      12B, bits:      30b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_REFCLK
#define h_REFCLK (){}

    #define     RA_REFCLK_CTRL                                 0x0000

    #define     BA_REFCLK_CTRL_CLK_SEL                         0x0000
    #define     B16REFCLK_CTRL_CLK_SEL                         0x0000
    #define   LSb32REFCLK_CTRL_CLK_SEL                            0
    #define   LSb16REFCLK_CTRL_CLK_SEL                            0
    #define       bREFCLK_CTRL_CLK_SEL                         2
    #define   MSK32REFCLK_CTRL_CLK_SEL                            0x00000003

    #define     BA_REFCLK_CTRL_PULL_DOWN                       0x0000
    #define     B16REFCLK_CTRL_PULL_DOWN                       0x0000
    #define   LSb32REFCLK_CTRL_PULL_DOWN                          2
    #define   LSb16REFCLK_CTRL_PULL_DOWN                          2
    #define       bREFCLK_CTRL_PULL_DOWN                       1
    #define   MSK32REFCLK_CTRL_PULL_DOWN                          0x00000004

    #define     BA_REFCLK_CTRL_TX_EN                           0x0000
    #define     B16REFCLK_CTRL_TX_EN                           0x0000
    #define   LSb32REFCLK_CTRL_TX_EN                              3
    #define   LSb16REFCLK_CTRL_TX_EN                              3
    #define       bREFCLK_CTRL_TX_EN                           1
    #define   MSK32REFCLK_CTRL_TX_EN                              0x00000008

    #define     BA_REFCLK_CTRL_IMP_CTRL                        0x0000
    #define     B16REFCLK_CTRL_IMP_CTRL                        0x0000
    #define   LSb32REFCLK_CTRL_IMP_CTRL                           4
    #define   LSb16REFCLK_CTRL_IMP_CTRL                           4
    #define       bREFCLK_CTRL_IMP_CTRL                        5
    #define   MSK32REFCLK_CTRL_IMP_CTRL                           0x000001F0

    #define     BA_REFCLK_CTRL_DE_EMP_EN                       0x0001
    #define     B16REFCLK_CTRL_DE_EMP_EN                       0x0000
    #define   LSb32REFCLK_CTRL_DE_EMP_EN                          9
    #define   LSb16REFCLK_CTRL_DE_EMP_EN                          9
    #define       bREFCLK_CTRL_DE_EMP_EN                       1
    #define   MSK32REFCLK_CTRL_DE_EMP_EN                          0x00000200

    #define     BA_REFCLK_CTRL_DE_EMP                          0x0001
    #define     B16REFCLK_CTRL_DE_EMP                          0x0000
    #define   LSb32REFCLK_CTRL_DE_EMP                             10
    #define   LSb16REFCLK_CTRL_DE_EMP                             10
    #define       bREFCLK_CTRL_DE_EMP                          3
    #define   MSK32REFCLK_CTRL_DE_EMP                             0x00001C00

    #define     BA_REFCLK_CTRL_USE_INPUT_CLK                   0x0001
    #define     B16REFCLK_CTRL_USE_INPUT_CLK                   0x0000
    #define   LSb32REFCLK_CTRL_USE_INPUT_CLK                      13
    #define   LSb16REFCLK_CTRL_USE_INPUT_CLK                      13
    #define       bREFCLK_CTRL_USE_INPUT_CLK                   1
    #define   MSK32REFCLK_CTRL_USE_INPUT_CLK                      0x00002000
    ///////////////////////////////////////////////////////////
    #define     RA_REFCLK_PLL_CTRL                             0x0004

    #define     BA_REFCLK_PLL_CTRL_RESET                       0x0004
    #define     B16REFCLK_PLL_CTRL_RESET                       0x0004
    #define   LSb32REFCLK_PLL_CTRL_RESET                          0
    #define   LSb16REFCLK_PLL_CTRL_RESET                          0
    #define       bREFCLK_PLL_CTRL_RESET                       1
    #define   MSK32REFCLK_PLL_CTRL_RESET                          0x00000001

    #define     BA_REFCLK_PLL_CTRL_BYPASS                      0x0004
    #define     B16REFCLK_PLL_CTRL_BYPASS                      0x0004
    #define   LSb32REFCLK_PLL_CTRL_BYPASS                         1
    #define   LSb16REFCLK_PLL_CTRL_BYPASS                         1
    #define       bREFCLK_PLL_CTRL_BYPASS                      1
    #define   MSK32REFCLK_PLL_CTRL_BYPASS                         0x00000002

    #define     BA_REFCLK_PLL_CTRL_SSMD                        0x0004
    #define     B16REFCLK_PLL_CTRL_SSMD                        0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSMD                           2
    #define   LSb16REFCLK_PLL_CTRL_SSMD                           2
    #define       bREFCLK_PLL_CTRL_SSMD                        3
    #define   MSK32REFCLK_PLL_CTRL_SSMD                           0x0000001C

    #define     BA_REFCLK_PLL_CTRL_SSDS                        0x0004
    #define     B16REFCLK_PLL_CTRL_SSDS                        0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSDS                           5
    #define   LSb16REFCLK_PLL_CTRL_SSDS                           5
    #define       bREFCLK_PLL_CTRL_SSDS                        1
    #define   MSK32REFCLK_PLL_CTRL_SSDS                           0x00000020

    #define     BA_REFCLK_PLL_CTRL_SSFIN100                    0x0004
    #define     B16REFCLK_PLL_CTRL_SSFIN100                    0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSFIN100                       6
    #define   LSb16REFCLK_PLL_CTRL_SSFIN100                       6
    #define       bREFCLK_PLL_CTRL_SSFIN100                    1
    #define   MSK32REFCLK_PLL_CTRL_SSFIN100                       0x00000040

    #define     BA_REFCLK_PLL_CTRL_SSFOUT100                   0x0004
    #define     B16REFCLK_PLL_CTRL_SSFOUT100                   0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSFOUT100                      7
    #define   LSb16REFCLK_PLL_CTRL_SSFOUT100                      7
    #define       bREFCLK_PLL_CTRL_SSFOUT100                   1
    #define   MSK32REFCLK_PLL_CTRL_SSFOUT100                      0x00000080

    #define     BA_REFCLK_PLL_CTRL_SSFOUT125                   0x0005
    #define     B16REFCLK_PLL_CTRL_SSFOUT125                   0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSFOUT125                      8
    #define   LSb16REFCLK_PLL_CTRL_SSFOUT125                      8
    #define       bREFCLK_PLL_CTRL_SSFOUT125                   1
    #define   MSK32REFCLK_PLL_CTRL_SSFOUT125                      0x00000100

    #define     BA_REFCLK_PLL_CTRL_SSFOUT250                   0x0005
    #define     B16REFCLK_PLL_CTRL_SSFOUT250                   0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSFOUT250                      9
    #define   LSb16REFCLK_PLL_CTRL_SSFOUT250                      9
    #define       bREFCLK_PLL_CTRL_SSFOUT250                   1
    #define   MSK32REFCLK_PLL_CTRL_SSFOUT250                      0x00000200

    #define     BA_REFCLK_PLL_CTRL_SSFOUT500                   0x0005
    #define     B16REFCLK_PLL_CTRL_SSFOUT500                   0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSFOUT500                      10
    #define   LSb16REFCLK_PLL_CTRL_SSFOUT500                      10
    #define       bREFCLK_PLL_CTRL_SSFOUT500                   1
    #define   MSK32REFCLK_PLL_CTRL_SSFOUT500                      0x00000400

    #define     BA_REFCLK_PLL_CTRL_SSICP                       0x0005
    #define     B16REFCLK_PLL_CTRL_SSICP                       0x0004
    #define   LSb32REFCLK_PLL_CTRL_SSICP                          11
    #define   LSb16REFCLK_PLL_CTRL_SSICP                          11
    #define       bREFCLK_PLL_CTRL_SSICP                       4
    #define   MSK32REFCLK_PLL_CTRL_SSICP                          0x00007800
    ///////////////////////////////////////////////////////////
    #define     RA_REFCLK_PLL_STATUS                           0x0008

    #define     BA_REFCLK_PLL_STATUS_LOCK                      0x0008
    #define     B16REFCLK_PLL_STATUS_LOCK                      0x0008
    #define   LSb32REFCLK_PLL_STATUS_LOCK                         0
    #define   LSb16REFCLK_PLL_STATUS_LOCK                         0
    #define       bREFCLK_PLL_STATUS_LOCK                      1
    #define   MSK32REFCLK_PLL_STATUS_LOCK                         0x00000001
    ///////////////////////////////////////////////////////////

    typedef struct SIE_REFCLK {
    ///////////////////////////////////////////////////////////
    #define   GET32REFCLK_CTRL_CLK_SEL(r32)                    _BFGET_(r32, 1, 0)
    #define   SET32REFCLK_CTRL_CLK_SEL(r32,v)                  _BFSET_(r32, 1, 0,v)
    #define   GET16REFCLK_CTRL_CLK_SEL(r16)                    _BFGET_(r16, 1, 0)
    #define   SET16REFCLK_CTRL_CLK_SEL(r16,v)                  _BFSET_(r16, 1, 0,v)

    #define   GET32REFCLK_CTRL_PULL_DOWN(r32)                  _BFGET_(r32, 2, 2)
    #define   SET32REFCLK_CTRL_PULL_DOWN(r32,v)                _BFSET_(r32, 2, 2,v)
    #define   GET16REFCLK_CTRL_PULL_DOWN(r16)                  _BFGET_(r16, 2, 2)
    #define   SET16REFCLK_CTRL_PULL_DOWN(r16,v)                _BFSET_(r16, 2, 2,v)

    #define   GET32REFCLK_CTRL_TX_EN(r32)                      _BFGET_(r32, 3, 3)
    #define   SET32REFCLK_CTRL_TX_EN(r32,v)                    _BFSET_(r32, 3, 3,v)
    #define   GET16REFCLK_CTRL_TX_EN(r16)                      _BFGET_(r16, 3, 3)
    #define   SET16REFCLK_CTRL_TX_EN(r16,v)                    _BFSET_(r16, 3, 3,v)

    #define   GET32REFCLK_CTRL_IMP_CTRL(r32)                   _BFGET_(r32, 8, 4)
    #define   SET32REFCLK_CTRL_IMP_CTRL(r32,v)                 _BFSET_(r32, 8, 4,v)
    #define   GET16REFCLK_CTRL_IMP_CTRL(r16)                   _BFGET_(r16, 8, 4)
    #define   SET16REFCLK_CTRL_IMP_CTRL(r16,v)                 _BFSET_(r16, 8, 4,v)

    #define   GET32REFCLK_CTRL_DE_EMP_EN(r32)                  _BFGET_(r32, 9, 9)
    #define   SET32REFCLK_CTRL_DE_EMP_EN(r32,v)                _BFSET_(r32, 9, 9,v)
    #define   GET16REFCLK_CTRL_DE_EMP_EN(r16)                  _BFGET_(r16, 9, 9)
    #define   SET16REFCLK_CTRL_DE_EMP_EN(r16,v)                _BFSET_(r16, 9, 9,v)

    #define   GET32REFCLK_CTRL_DE_EMP(r32)                     _BFGET_(r32,12,10)
    #define   SET32REFCLK_CTRL_DE_EMP(r32,v)                   _BFSET_(r32,12,10,v)
    #define   GET16REFCLK_CTRL_DE_EMP(r16)                     _BFGET_(r16,12,10)
    #define   SET16REFCLK_CTRL_DE_EMP(r16,v)                   _BFSET_(r16,12,10,v)

    #define   GET32REFCLK_CTRL_USE_INPUT_CLK(r32)              _BFGET_(r32,13,13)
    #define   SET32REFCLK_CTRL_USE_INPUT_CLK(r32,v)            _BFSET_(r32,13,13,v)
    #define   GET16REFCLK_CTRL_USE_INPUT_CLK(r16)              _BFGET_(r16,13,13)
    #define   SET16REFCLK_CTRL_USE_INPUT_CLK(r16,v)            _BFSET_(r16,13,13,v)

    #define     w32REFCLK_CTRL                                 {\
            UNSG32 uCTRL_CLK_SEL                               :  2;\
            UNSG32 uCTRL_PULL_DOWN                             :  1;\
            UNSG32 uCTRL_TX_EN                                 :  1;\
            UNSG32 uCTRL_IMP_CTRL                              :  5;\
            UNSG32 uCTRL_DE_EMP_EN                             :  1;\
            UNSG32 uCTRL_DE_EMP                                :  3;\
            UNSG32 uCTRL_USE_INPUT_CLK                         :  1;\
            UNSG32 RSVDx0_b14                                  : 18;\
          }
    union { UNSG32 u32REFCLK_CTRL;
            struct w32REFCLK_CTRL;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32REFCLK_PLL_CTRL_RESET(r32)                  _BFGET_(r32, 0, 0)
    #define   SET32REFCLK_PLL_CTRL_RESET(r32,v)                _BFSET_(r32, 0, 0,v)
    #define   GET16REFCLK_PLL_CTRL_RESET(r16)                  _BFGET_(r16, 0, 0)
    #define   SET16REFCLK_PLL_CTRL_RESET(r16,v)                _BFSET_(r16, 0, 0,v)

    #define   GET32REFCLK_PLL_CTRL_BYPASS(r32)                 _BFGET_(r32, 1, 1)
    #define   SET32REFCLK_PLL_CTRL_BYPASS(r32,v)               _BFSET_(r32, 1, 1,v)
    #define   GET16REFCLK_PLL_CTRL_BYPASS(r16)                 _BFGET_(r16, 1, 1)
    #define   SET16REFCLK_PLL_CTRL_BYPASS(r16,v)               _BFSET_(r16, 1, 1,v)

    #define   GET32REFCLK_PLL_CTRL_SSMD(r32)                   _BFGET_(r32, 4, 2)
    #define   SET32REFCLK_PLL_CTRL_SSMD(r32,v)                 _BFSET_(r32, 4, 2,v)
    #define   GET16REFCLK_PLL_CTRL_SSMD(r16)                   _BFGET_(r16, 4, 2)
    #define   SET16REFCLK_PLL_CTRL_SSMD(r16,v)                 _BFSET_(r16, 4, 2,v)

    #define   GET32REFCLK_PLL_CTRL_SSDS(r32)                   _BFGET_(r32, 5, 5)
    #define   SET32REFCLK_PLL_CTRL_SSDS(r32,v)                 _BFSET_(r32, 5, 5,v)
    #define   GET16REFCLK_PLL_CTRL_SSDS(r16)                   _BFGET_(r16, 5, 5)
    #define   SET16REFCLK_PLL_CTRL_SSDS(r16,v)                 _BFSET_(r16, 5, 5,v)

    #define   GET32REFCLK_PLL_CTRL_SSFIN100(r32)               _BFGET_(r32, 6, 6)
    #define   SET32REFCLK_PLL_CTRL_SSFIN100(r32,v)             _BFSET_(r32, 6, 6,v)
    #define   GET16REFCLK_PLL_CTRL_SSFIN100(r16)               _BFGET_(r16, 6, 6)
    #define   SET16REFCLK_PLL_CTRL_SSFIN100(r16,v)             _BFSET_(r16, 6, 6,v)

    #define   GET32REFCLK_PLL_CTRL_SSFOUT100(r32)              _BFGET_(r32, 7, 7)
    #define   SET32REFCLK_PLL_CTRL_SSFOUT100(r32,v)            _BFSET_(r32, 7, 7,v)
    #define   GET16REFCLK_PLL_CTRL_SSFOUT100(r16)              _BFGET_(r16, 7, 7)
    #define   SET16REFCLK_PLL_CTRL_SSFOUT100(r16,v)            _BFSET_(r16, 7, 7,v)

    #define   GET32REFCLK_PLL_CTRL_SSFOUT125(r32)              _BFGET_(r32, 8, 8)
    #define   SET32REFCLK_PLL_CTRL_SSFOUT125(r32,v)            _BFSET_(r32, 8, 8,v)
    #define   GET16REFCLK_PLL_CTRL_SSFOUT125(r16)              _BFGET_(r16, 8, 8)
    #define   SET16REFCLK_PLL_CTRL_SSFOUT125(r16,v)            _BFSET_(r16, 8, 8,v)

    #define   GET32REFCLK_PLL_CTRL_SSFOUT250(r32)              _BFGET_(r32, 9, 9)
    #define   SET32REFCLK_PLL_CTRL_SSFOUT250(r32,v)            _BFSET_(r32, 9, 9,v)
    #define   GET16REFCLK_PLL_CTRL_SSFOUT250(r16)              _BFGET_(r16, 9, 9)
    #define   SET16REFCLK_PLL_CTRL_SSFOUT250(r16,v)            _BFSET_(r16, 9, 9,v)

    #define   GET32REFCLK_PLL_CTRL_SSFOUT500(r32)              _BFGET_(r32,10,10)
    #define   SET32REFCLK_PLL_CTRL_SSFOUT500(r32,v)            _BFSET_(r32,10,10,v)
    #define   GET16REFCLK_PLL_CTRL_SSFOUT500(r16)              _BFGET_(r16,10,10)
    #define   SET16REFCLK_PLL_CTRL_SSFOUT500(r16,v)            _BFSET_(r16,10,10,v)

    #define   GET32REFCLK_PLL_CTRL_SSICP(r32)                  _BFGET_(r32,14,11)
    #define   SET32REFCLK_PLL_CTRL_SSICP(r32,v)                _BFSET_(r32,14,11,v)
    #define   GET16REFCLK_PLL_CTRL_SSICP(r16)                  _BFGET_(r16,14,11)
    #define   SET16REFCLK_PLL_CTRL_SSICP(r16,v)                _BFSET_(r16,14,11,v)

    #define     w32REFCLK_PLL_CTRL                             {\
            UNSG32 uPLL_CTRL_RESET                             :  1;\
            UNSG32 uPLL_CTRL_BYPASS                            :  1;\
            UNSG32 uPLL_CTRL_SSMD                              :  3;\
            UNSG32 uPLL_CTRL_SSDS                              :  1;\
            UNSG32 uPLL_CTRL_SSFIN100                          :  1;\
            UNSG32 uPLL_CTRL_SSFOUT100                         :  1;\
            UNSG32 uPLL_CTRL_SSFOUT125                         :  1;\
            UNSG32 uPLL_CTRL_SSFOUT250                         :  1;\
            UNSG32 uPLL_CTRL_SSFOUT500                         :  1;\
            UNSG32 uPLL_CTRL_SSICP                             :  4;\
            UNSG32 RSVDx4_b15                                  : 17;\
          }
    union { UNSG32 u32REFCLK_PLL_CTRL;
            struct w32REFCLK_PLL_CTRL;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32REFCLK_PLL_STATUS_LOCK(r32)                 _BFGET_(r32, 0, 0)
    #define   SET32REFCLK_PLL_STATUS_LOCK(r32,v)               _BFSET_(r32, 0, 0,v)
    #define   GET16REFCLK_PLL_STATUS_LOCK(r16)                 _BFGET_(r16, 0, 0)
    #define   SET16REFCLK_PLL_STATUS_LOCK(r16,v)               _BFSET_(r16, 0, 0,v)

    #define     w32REFCLK_PLL_STATUS                           {\
            UNSG32 uPLL_STATUS_LOCK                            :  1;\
            UNSG32 RSVDx8_b1                                   : 31;\
          }
    union { UNSG32 u32REFCLK_PLL_STATUS;
            struct w32REFCLK_PLL_STATUS;
          };
    ///////////////////////////////////////////////////////////
    } SIE_REFCLK;

    typedef union  T32REFCLK_CTRL
          { UNSG32 u32;
            struct w32REFCLK_CTRL;
                 } T32REFCLK_CTRL;
    typedef union  T32REFCLK_PLL_CTRL
          { UNSG32 u32;
            struct w32REFCLK_PLL_CTRL;
                 } T32REFCLK_PLL_CTRL;
    typedef union  T32REFCLK_PLL_STATUS
          { UNSG32 u32;
            struct w32REFCLK_PLL_STATUS;
                 } T32REFCLK_PLL_STATUS;
    ///////////////////////////////////////////////////////////

    typedef union  TREFCLK_CTRL
          { UNSG32 u32[1];
            struct {
            struct w32REFCLK_CTRL;
                   };
                 } TREFCLK_CTRL;
    typedef union  TREFCLK_PLL_CTRL
          { UNSG32 u32[1];
            struct {
            struct w32REFCLK_PLL_CTRL;
                   };
                 } TREFCLK_PLL_CTRL;
    typedef union  TREFCLK_PLL_STATUS
          { UNSG32 u32[1];
            struct {
            struct w32REFCLK_PLL_STATUS;
                   };
                 } TREFCLK_PLL_STATUS;

    ///////////////////////////////////////////////////////////
     SIGN32 REFCLK_drvrd(SIE_REFCLK *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 REFCLK_drvwr(SIE_REFCLK *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void REFCLK_reset(SIE_REFCLK *p);
     SIGN32 REFCLK_cmp  (SIE_REFCLK *p, SIE_REFCLK *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define REFCLK_check(p,pie,pfx,hLOG) REFCLK_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define REFCLK_print(p,    pfx,hLOG) REFCLK_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: REFCLK
////////////////////////////////////////////////////////////

//////
///
/// $INTERFACE PCIE                    biu              (4,4)
///     ###
///     * PCI-E module register space
///     ###
///     # # ----------------------------------------------------------
///     @ 0x00000                      (P)
///     # 0x00000 IP_REGSP_0
///               $IP_REGSP_0          IP_REGSP_0        MEM
///                                    ###
///                                    * PCIE 3 IP First 32KB register Space
///                                    ###
///     @ 0x08000                      (P)
///     # 0x08000 IP_REGSP_1
///               $IP_REGSP_1          IP_REGSP_1        MEM
///                                    ###
///                                    * PCIE 3 IP Second 8KB register Space, So total IP Register space is 40KB
///                                    ###
///     @ 0x0A000 MSI_INTR_RX          (RW-)
///               ###
///               * PCI-E MSI Received register
///               ###
///               %unsigned 32 DATA                      0x0
///                                    ###
///                                    * Data Received register
///                                    * The received data decides which function generated the interrupt. This data is used to set the corresponding bits in the INTR Status register
///                                    * Note: Software should use the [15:13] bits as the function ID while programming the MSI DATA register in the endpoint
///                                    * Endpoint should use the [1:0] bits to indicate what type of interrupt is this.
///                                    ###
///     @ 0x0A004 MSI_INTR_STATUS      (WOC-)
///               ###
///               * PCI-E MSI Interrupt Status register
///               * BG3 supports MSI for 8 functions and each function can have 4 types of interrupts.
///               * The register implements 4 Interrupt bits for each function.
///               * A value of 1 : indicates that the interrupt is pending for that function
///               * A value of 0 : indicates no interrupt pending
///               * Note: Write-1-to clear the interrupt in this register
///               ###
///               %unsigned 32 VALUE                     0x0
///                                    ###
///                                    * MSI Interrupt status
///                                    * The bits in this register indicates MSI Interrupt status for the 8 functions.
///                                    * For each bit :
///                                    * 0 : means Interrupt is not pending
///                                    * 1 : means Interrupt is pending
///                                    * The following is the mapping between function and interrupt bits:
///                                    * Bits [3:0]     : MSI Interrupt status for Function 0 interrupts
///                                    * Bits [7:4]     : MSI Interrupt status for Function 1 interrupts
///                                    * Bits [11:8]   : MSI Interrupt status for Function 2 interrupts
///                                    * Bits [15:12] : MSI Interrupt status for Function 3 interrupts
///                                    * Bits [19:16] : MSI Interrupt status for Function 4 interrupts
///                                    * Bits [23:20] : MSI Interrupt status for Function 5 interrupts
///                                    * Bits [27:24] : MSI Interrupt status for Function 6 interrupts
///                                    * Bits [31:28] : MSI Interrupt status for Function 7 interrupts
///                                    * Each function has 4-bits each (so can have 4 different types of interrupts). If any of them is set, it means corresponding Interrupt for that function is pending.
///                                    ###
///     @ 0x0A008 MSI_INTR_MASK        (RW)
///               ###
///               * PCI-E MSI Interrupt Mask register
///               ###
///               %unsigned 32 VALUE                     0x0
///                                    ###
///                                    *   Interrupt Mask
///                                    * 0 : Interrupt enabled
///                                    * 1 : Interrupt disabled (masked)
///                                    * Bits [3:0] : Interrupt Mask for Function 0 interrupts
///                                    * Bits [7:4] : Interrupt Mask for Function 1 interrupts
///                                    * Bits [11:8] : Interrupt Mask for Function 2 interrupts
///                                    * Bits [15:12] : Interrupt Mask for Function 3 interrupts
///                                    * Bits [19:16] : Interrupt Mask for Function 4 interrupts
///                                    * Bits [23:20] : Interrupt Mask for Function 5 interrupts
///                                    * Bits [27:24] : Interrupt Mask for Function 6 interrupts
///                                    * Bits [31:28] : Interrupt Mask for Function 7 interrupts
///                                    ###
///     @ 0x0A00C MAC_INTR_STATUS      (WOC-)
///               ###
///               * Writing ones to any of the bits will clear the corresponding bits.
///               ###
///               %unsigned 1  AXI_ADDR_OOR              0x0
///                                    ###
///                                    * The interrupt of out of range. This bit is set if AXI master is trying to access the memory that is out of the range of [ADDR_FILTER_LOWER, ADDR_FILTER_UPPER].
///                                    ###
///               %unsigned 1  MSI_CTRL_INT              0x0
///                                    ###
///                                    * MSI Interrupt Detected. Asserted when an MSI
///                                    * interrupt is pending. De-asserted when there is no MSI interrupt
///                                    * pending.
///                                    ###
///               %unsigned 1  HP_INT                    0x0
///                                    ###
///                                    * The core asserts hp_int when all of the following
///                                    * conditions are true:
///                                    * ■ The INTx Assertion Disable bit in the Command register is 0.
///                                    * ■ Hot-Plug interrupts are enabled in the Slot Control register.
///                                    * ■ Any bit in the Slot Status register is equal to 1, and the associated
///                                    * event notification is enabled inthe Slot Control register
///                                    ###
///               %unsigned 1  CFG_PME_INT               0x0
///                                    ###
///                                    * The coreasserts cfg_pme_int when all of the following
///                                    * conditions are true:
///                                    * ■ The INTx Assertion Disable bit in the Command register is 0.
///                                    * ■ The PME Interrupt Enable bit in the Root Control register is set to
///                                    * 1.
///                                    * ■ The PME Status bit in the Root Status register is set to 1.
///                                    * The cfg_pme_msi output is a pulse signal (only asserted for one
///                                    * clock cycle). But cfg_pme_int is a level signal; essentially an AND of
///                                    * the PME interrupt enable and receipt of the pm_pme message.
///                                    ###
///               %unsigned 1  CFG_AER_RC_ERR_INT        0x0
///                                    ###
///                                    * Asserted when a reported error condition causes a bit
///                                    * to be set in the Root Error Status register and the associated error
///                                    * message reporting enable bit is set in the Root Error Command
///                                    * register. cfg_aer_rc_err_int is set when the RC internally generates
///                                    * an error or when an error message is received by the RC. Since the
///                                    * RC itself generates it, this needs to be propagated up to the system
///                                    * software which would then need to read the error registers to see
///                                    * which error occurred.
///                                    ###
///               %unsigned 1  CFG_AER_RC_ERR_MSI        0x0
///                                    ###
///                                    * Asserted for one clock cyclewhen all of the following
///                                    * conditions are true:
///                                    * ■ MSI or MSI-X is enabled.
///                                    * ■ A reported error condition causes a bit to be set in the Root Error
///                                    * Status register.
///                                    * ■ The associated error message reporting enable bit is set in the
///                                    * Root Error Command register.
///                                    * The core does not check if the associated MSI vector (asserted
///                                    * cfg_aer_int_msg_num) is unmasked. It is up to the application to
///                                    * check whether the vectoris masked or unmasked.
///                                    ###
///               %unsigned 1  CFG_SYS_ERR_RC            0x0
///                                    ###
///                                    * System error detected. A one-clock-cycle pulse that
///                                    * indicates if any device in the hierarchy reports any of the following
///                                    * errors and the associated enable bit is set in the Root Control
///                                    * register: ERR_COR, ERR_FATAL,ERR_NONFATAL. Also asserted
///                                    * when an internal error is detected. There is one bit of cfg_sys_err_rc
///                                    * assigned to each configured function.
///                                    ###
///               %unsigned 1  CFG_PME_MSI               0x0
///                                    ###
///                                    * The core asserts cfg_pme_msi (as a one-cycle pulse)
///                                    * when all of the following conditions are true:
///                                    * ■ MSI or MSI-X is enabled.
///                                    * ■ The PME Interrupt Enable bit in the Root Control register is set to
///                                    * 1.
///                                    * ■ The PME Status bit in the Root Status register is set to 1.
///                                    * The core does not check if the associated MSI vector (asserted
///                                    * cfg_pcie_cap_int_msg_num) is unmasked. It is up to the application
///                                    * to check whether the vector is masked or unmasked.
///                                    ###
///               %unsigned 1  RADM_CORRECTABLE_ERR      0x0
///                                    ###
///                                    * One-clock-cycle pulse thatindicates that the core
///                                    * received an ERR_COR message. The core makes the message
///                                    * header available the radm_msg_payload output.
///                                    ###
///               %unsigned 1  RADM_NONFATAL_ERR         0x0
///                                    ###
///                                    * One-clock-cycle pulse thatindicates that the core
///                                    * received an ERR_NONFATAL message. The core makes the
///                                    * message header available the radm_msg_payload output.
///                                    ###
///               %unsigned 1  RADM_FATAL_ERR            0x0
///                                    ###
///                                    * One-clock-cycle pulse thatindicates that the core
///                                    * received an ERR_FATAL message. The core makes the message
///                                    * header available the radm_msg_payload output.
///                                    ###
///               %unsigned 1  RADM_PM_PME               0x0
///                                    ###
///                                    * One-clock-cycle pulse thatindicates that the core
///                                    * received a PM_PME message. The core makes the message header
///                                    * available the radm_msg_payload output.
///                                    ###
///               %unsigned 1  RADM_PM_TO_ACK            0x0
///                                    ###
///                                    * One-clock-cycle pulse thatindicates that the core
///                                    * received a PME_TO_Ack message. The core makes the message
///                                    * header available the radm_msg_payload output.
///                                    ###
///               %unsigned 1  HP_PME                    0x0
///                                    ###
///                                    * The core asserts hp_pme when all of the following
///                                    * conditions are true:
///                                    * ■ The PME Enable bit in the Power Management Control and
///                                    * Status register is set to 1.
///                                    * ■ Any bit in the Slot Status register transitions from 0 to 1 and the
///                                    * associated event notification isenabled in the Slot Control
///                                    * register.
///                                    * The core does not check if the PM state is D1, D2, or D3hot. It is up
///                                    * to your application to check the value pm_dstate to make sure the
///                                    * device is in D1, D2, or D3hot. There is one bit of hp_pme for each
///                                    * configured function. The core pulses the hp_pme output only when
///                                    * any hot plug status bit changes from0 to 1 (as is hp_msi). hp_int
///                                    * stays asserted as long as the status bit is set. In addition, it asserts
///                                    * hp_pme only if PME is enabled, but it does not matter if hot-plug
///                                    * interrupts are enabled.
///                                    ###
///               %unsigned 1  HP_MSI                    0x0
///                                    ###
///                                    * The core asserts hp_msi (as a one-cycle pulse) when
///                                    * the logical AND of the following conditions transitions from false to
///                                    * true:
///                                    * ■ MSI or MSI-X is enabled.
///                                    * ■ Hot-Plug interrupts are enabled in the Slot Control register.
///                                    * ■ Any bit in the Slot Status register transitions from 0 to 1 and the
///                                    * associated event notification isenabled in the Slot Control
///                                    * register.
///                                    * There is one bit of hp_int for each configured function. The core
///                                    * pulses the hp_msi output only whenany of the hot plug status bits
///                                    * change from 0 to 1 (as is hp_pme).
///                                    ###
///               %unsigned 1  CFG_LINK_AUTO_BW_INT      0x0
///                                    ###
///                                    * This pin is set as a notification when the Link
///                                    * Autonomous Bandwidth Status register (Link Status register bit 15) is
///                                    * updated and the Link Autonomous Bandwidth Interrupt Enable (Link
///                                    * Control register bit 11) is set.
///                                    ###
///               %unsigned 1  CFG_LINK_AUTO_BW_MSI      0x0
///                                    ###
///                                    * he controller sets this pin when following conditions are true:
///                                    * MSI or MSI-X is enabled.
///                                    * ■
///                                    * The Link Autonomous Bandwidth Status register (Link Status
///                                    * register bit 15) is updated.
///                                    * ■
///                                    * The Link Autonomous Bandwidth Interrupt Enable (Link Control
///                                    * register bit 11) is set.
///                                    * The controller does not check if the associated MSI vector (asserted
///                                    * cfg_pcie_cap_int_msg_num) is unmasked. It is up to the application to
///                                    * check whether the vector is masked or unmasked.
///                                    ###
///               %unsigned 1  CFG_BW_MGT_INT            0x0
///                                    ###
///                                    * This pin is set as a notification when the Link
///                                    * Bandwidth Management Status register (Link Status register bit 14)
///                                    * is updated and the Link Bandwidth Management Interrupt Enable
///                                    * (Link Control register bit 10) is set.
///                                    ###
///               %unsigned 1  CFG_BW_MGT_MSI            0x0
///                                    ###
///                                    * The controller sets this pin when following conditions are true:
///                                    * MSI or MSI-X is enabled.
///                                    * ■
///                                    * The Link Bandwidth Management Status register (Link Control
///                                    * Status register bit 14) is updated
///                                    * ■
///                                    * The Link Bandwidth Management Interrupt Enable (Link Control
///                                    * register bit 10) is set.
///                                    * reuse-pragma beginAttr Description This pin is set as a notification
///                                    * when the Link Bandwidth Management Status register (Link Status
///                                    * register bit 14) is updated and the Link Bandwidth Management
///                                    * Interrupt Enable (Link Control register bit 10) is set and in addition the
///                                    * msi or msix aare enabled . This bit is not applicable to, and is reserved,
///                                    * for endpoint devices and upstream ports of Switches.
///                                    ###
///               %unsigned 1  RADM_INTA_ASSERTED        0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Assert_INTA Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTB_ASSERTED        0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Assert_INTB Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTC_ASSERTED        0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Assert_INTC Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTD_ASSERTED        0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Assert_INTD Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTA_DEASSERTED      0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Deassert_INTA Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTB_DEASSERTED      0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Deassert_INTB Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTC_DEASSERTED      0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Deassert_INTC Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_INTD_DEASSERTED      0x0
///                                    ###
///                                    * One-clock-cycle pulse that indicates that the core
///                                    * received a Legacy Deassert_INTD Message from the downstream device
///                                    ###
///               %unsigned 1  RADM_QOVERFLOW            0x0
///                                    ###
///                                    * Pulse indicating that one or more of the P/NP/CPL receive queues have overflowed. There is a 1-bit indication for each configured virtual channel.
///                                    * Active State: High pulse indicates overflow
///                                    ###
///               %unsigned 1  SMLH_LINK_UP              0x0
///                                    ###
///                                    * This interrupt indicates that the Physical Link is Up
///                                    ###
///               %unsigned 1  SMLH_LINK_DN              0x0
///                                    ###
///                                    * This interrupt indicates that the physical link is down now
///                                    ###
///               %unsigned 1  RADM_CPL_TIMEOUT          0x0
///                                    ###
///                                    * This interrupt indicates that the Receiver has CPL time out now for previously sent request.
///                                    ###
///               %%        1          # Stuffing bits...
///     @ 0x0A010 MAC_INTR_MASK        (P)
///               %unsigned 32 INTR_MASK                 0x0
///                                    ###
///                                    * Interrupt masks: bit i is used to mask MAC_INTR_STATUS bit i.
///                                    * When a bit is masked, it won't trigger a interrupt. Value of MAC_INTR_STATUS itself is not affected by this MAC_INTR_MASK.
///                                    ###
///     @ 0x0A014 MAC_INTR_STATUS1     (WOC-)
///               ###
///               * Interrupt status 1 Register Writing ones to any of the bits will clear the corresponding bits.
///               ###
///               %unsigned 1  RADM_TRGT1_ATU0_SLOC_MATCH 0x0
///                                    ###
///                                    * Interrupt for ATU Single Location match indication for ATU region0. Asserted when the ATU region matched a received VDM Single Location Address translation.
///                                    ###
///               %unsigned 1  RADM_TRGT1_ATU0_CBUF_ERR  0x0
///               %unsigned 1  RADM_TRGT1_ATU1_SLOC_MATCH 0x0
///                                    ###
///                                    * Interrupt for ATU Single Location match indication for ATU region1. Asserted when the ATU region matched a received VDM Single Location Address translation.
///                                    ###
///               %unsigned 1  RADM_TRGT1_ATU1_CBUF_ERR  0x0
///               %%        28         # Stuffing bits...
///     @ 0x0A018 MAC_INTR_MASK1       (P)
///               %unsigned 32 INTR_MASK1                0x0
///                                    ###
///                                    * Interrupt masks: bit i is used to mask MAC_INTR_STATUS1 bit i.
///                                    * When a bit is masked, it won't trigger a interrupt. Value of MAC_INTR_STATUS itself is not affected by this MAC_INTR_MASK1.
///                                    ###
///     @ 0x0A01C MAC_CTRL             (RW)
///               ###
///               * PCIE MAC control register
///               ###
///               %unsigned 1  SYSWREQ                   0x0
///                                    ###
///                                    * AXI Lower power control bit
///                                    ###
///               %unsigned 1  CPU_INTERFACE_SEL         0x0
///                                    ###
///                                    * CPU Interface selection bit
///                                    * 0 : Use AHB to access PCIE registers
///                                    * 1 : Use SIF Serial interface to access the registers
///                                    ###
///               %unsigned 1  CFG_TYPE                  0x0
///                                    ###
///                                    * Register bit to indicate whether outbound CFG cycles are Type 0 or Type1
///                                    * 0 :   Type 0 configuration cycles (default)
///                                    * 1 :   Type 1 configuration cycles cd
///                                    ###
///               %unsigned 1  MEMMAP_CFG_VALID          0x1
///                                    ###
///                                    * Register bit to indicate whether Memory Mapped CFG cycles are supported or not.
///                                    * 0 : Memory mapped CFG cycles are not supported
///                                    * 1 : Memory mapped CFG cycles are supported
///                                    * Note: When this bit 0 : All the AXI transactions on the outbound will be send as Memory TLPs
///                                    * When this bit is 1     : The 512MB address space for PCIE in the chip is divided into parts, with lower 256MB for MEM and upper 256MB for CFG access.
///                                    ###
///               %unsigned 1  SYS_AUX_PWR_DET           0x0
///                                    ###
///                                    * Select clock source for mux_aux_clk:
///                                    * 0: auxClk
///                                    * 1: core_clk
///                                    ###
///               %unsigned 1  APP_LTSSM_ENABLE          0x0
///                                    ###
///                                    * Driven low by application after reset to hold the
///                                    * LTSSM in the Detect state until application is ready. When application has finished initializing the core configuration registers, asserts it to allow the LTSSM to continue link
///                                    * establishment.
///                                    ###
///               %unsigned 1  CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN 0x0
///                                    ###
///                                    * While in L1 enable AUX clock to switch from PCLK to free running external clock:
///                                    * 1: enable; 0: disable
///                                    ###
///               %unsigned 1  CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN 0x0
///                                    ###
///                                    * While in L1 enable overriding the powerdown signal from the core from P1 to P2:
///                                    * 1: enable; 0: disable
///                                    ###
///               %unsigned 1  ADDR_FILTER_FLAG          0x0
///                                    ###
///                                    * Give CPU the access right to program memory boundary registers ( ADDR_FILTER_UPPER and ADDR_FILTER_LOWER)
///                                    * 0: CPU can program two boundary registers;
///                                    * 1: CPU cannot program two boundary registers.
///                                    * Note: after power up, this flag register's default value is 0, that means CPU can access two boundary registers; once CPU completes programming two boundary registers, this flag register will be set to 1 by hardware and cannot be programmed by CPU until next power up.
///                                    ###
///               %unsigned 1  PCIEM_DS_RESP_MASK_N      0x0
///                                    ###
///                                    * 1: DECERR is passed as is on BRESP and RRESP to pcie.
///                                    * 0: DECERR is masked. OKAY response is sent on both BRESP & RRESP to pcie.
///                                    ###
///               %unsigned 1  CLK_RST_BYPASS            0x0
///                                    ###
///                                    * To bypass clock_reset module.
///                                    * 0: enable clok_reset module;
///                                    * 1: bypass clock_reset module.
///                                    ###
///               %unsigned 1  MAC_DBI_CS2_ENABLE        0x0
///                                    ###
///                                    * 0: disable DBI_CS2
///                                    * 1: enable DBI_CS2
///                                    * By default, DBI_CS2 is disabled
///                                    ###
///               %unsigned 1  MAC_DBI_iATU_ADDR_SEL     0x0
///                                    ###
///                                    * 0: disable DBI_CS
///                                    * 1: enable DBI_CS
///                                    * By default, DBI_CS is enabled
///                                    ###
///               %unsigned 1  APP_CLK_REQ_N             0x1
///                                    ###
///                                    * Indicates that the application logic is ready to have reference clock removed
///                                    * 0: request to remove reference clock
///                                    * 1: don't remove reference clock
///                                    ###
///               %unsigned 1  APP_REQ_EXIT_L1           0x0
///                                    ###
///                                    * Application request to Exit L1. Request from your application to exit ASPM state L1. It's only effective when L1 is enabled.
///                                    * 1: request to exit L1.
///                                    ###
///               %unsigned 1  APP_XFER_PENDING          0x0
///                                    ###
///                                    * Indicates that your application has transfers pending and prevents
///                                    * the core from entering L1. This is a level signal used to inform the
///                                    * core about the state of external queues and pipeline stages that
///                                    * contain transactions to be transmitted by the core. The core uses this
///                                    * information to determine when to enter/exit L1. When this signal is
///                                    * asserted, it indicates that there are transactions outside the core that
///                                    * the core needs to transmit. When de-asserted, it indicates that there
///                                    * are no transactions outside the core. The core responds to an
///                                    * assertion on this signal as follows: ASPM L1 entry requests (from
///                                    * the link partner) will receive a PM_Active_State_Nak response.
///                                    * Triggers exit if already in L1. You can instruct the core to exit L1 by
///                                    * asserting either or both of app_xfer_pending and app_req_exit_l1.
///                                    * The core only samples app_req_exit_l1 when the core is already in
///                                    * the L1 state.
///                                    * Active high.
///                                    ###
///               %unsigned 1  APP_CLK_PM_EN             0x0
///                                    ###
///                                    * Clock PM feature enabled by application. Used to inhibit the programming of the Clock PM in Link Control Register.
///                                    * Active low
///                                    ###
///               %unsigned 1  PIPE2PIPE_BYPASS          0x0
///               %unsigned 1  APPS_PM_XMT_TURNOFF       0x0
///                                    ###
///                                    * Request from the application to generate a PM_Turn_off message. We must assert this signal for one clock cycle (this is done in hardware). Active: High. Sync to coreClk
///                                    ###
///               %unsigned 1  CLEAR_L2_INTR             0x0
///                                    ###
///                                    * 1 to clear L2 exit interrupt
///                                    ###
///               %unsigned 1  SLV_WMISC_INFO            0x0
///                                    ###
///                                    * AXI Slave Write Data transaction related misc information. This is an
///                                    * optional signal that your application can use to poison write requests.
///                                    * When asserted, the controller sets the Poisoned TLP (EP) bit in the TLP
///                                    * header of the current and subsequent Write Data transactions. It is not a
///                                    * part of the standard AXI interface.
///                                    ###
///               %unsigned 1  APP_DBI_RO_WR_DIS         0x1
///                                    ###
///                                    * Disable the writing of RO bits from Application
///                                    ###
///               %unsigned 1  RX_LANE_FLIP_EN           0x0
///                                    ###
///                                    * Performs manual lane reversal for RX Lanes
///                                    ###
///               %unsigned 1  TX_LANE_FLIP_EN           0x0
///                                    ###
///                                    * Performs manual lane reversal for TX Lanes
///                                    ###
///               %unsigned 1  APP_HOLD_PHY_RST          0x0
///                                    ###
///                                    * Setting this Holds the PHY Reset for any programming.
///                                    * - Not expected to use in this revision
///                                    ###
///               %%        7          # Stuffing bits...
///     @ 0x0A020 MAC_STATUS           (R-)
///               ###
///               * PCIE MAC misc status register
///               ###
///               %unsigned 1  DWACK
///                                    ###
///                                    * AXI low power status
///                                    ###
///               %unsigned 1  RDLH_LINK_UP
///                                    ###
///                                    * Data link layer up/down indicator: This status from the flow control
///                                    * initialization state machine indicates that flow control has been
///                                    * initiated and the Data link layer is ready to transmit and receive
///                                    * packets. For multi-VC designs, this signal indicates status for VC0
///                                    * only.
///                                    * 1: Link is up
///                                    * 0: Link is down
///                                    ###
///               %unsigned 3  PM_CURNT_STATE
///                                    ###
///                                    * Indicates the current power state.
///                                    ###
///               %unsigned 6  SMLH_LTSSM_STATE
///                                    ###
///                                    * Current state of the LTSSM. Encoding is defined in
///                                    * workspace/src/include/cxpl_defs.vh.
///                                    ###
///               %unsigned 1  SMLH_LINK_UP
///                                    ###
///                                    * PHY Link up/down indicator:
///                                    * 1: Link is up
///                                    * 0: Link is down
///                                    ###
///               %unsigned 1  RADM_Q_NOT_EMPTY
///                                    ###
///                                    * Level indicating that the receive queues contain TLP header/data.
///                                    * Active State: High indicates data in queues
///                                    ###
///               %unsigned 1  TRGT_CPL_TIMEOUT
///                                    ###
///                                    * Indicates that the application has not generated a completion for an
///                                    * incoming request within the required time interval. Information about
///                                    * the timed out completion is available the trgt_timeout_* outputs listed
///                                    * later. When a completion timeout occurs, the core clears the
///                                    * corresponding entry from the completion lookup table. The default
///                                    * completion timeout value is approximately 10 ms.
///                                    * Active: high
///                                    ###
///               %unsigned 1  PM_XTLH_BLOCK_TLP
///                                    ###
///                                    * Indicates that your application must stop generating new outgoing
///                                    * request TLPs due to the current power management state. Your application can continue to generate completion TLPs.
///                                    * Active: high
///                                    ###
///               %unsigned 1  BRDG_SLV_XFER_PENDING
///                                    ###
///                                    * AXI Slave transfer pending status. Indicates AXI Slave Read or Write transfers are pending, that is, AXI Slave transfers are awaiting a
///                                    * response from the core.
///                                    * Active: high
///                                    ###
///               %unsigned 1  RADM_CPL_TIMEOUT
///                                    ###
///                                    * Indicates that the completion TLP for a request has not been received within the expected time window
///                                    * Active: high
///                                    ###
///               %unsigned 8  CFG_INT_PIN
///                                    ###
///                                    * The cfg_int_pin indicates the configured value for the Interrupt Pin
///                                    * Register field in the BRIDGE_CTRL_INT_PIN_INT_LINE register.
///                                    ###
///               %%        7          # Stuffing bits...
///     @ 0x0A024 MAC_RID_REG          (RW)
///               ###
///               * PCIE MAC Programmable Requested ID Register
///               ###
///               %unsigned 8  BUS_NUM                   0x0
///                                    ###
///                                    * Bus Number part of RID
///                                    ###
///               %unsigned 5  DEV_NUM                   0x0
///                                    ###
///                                    * Device Number part of RID
///                                    ###
///               %%        19         # Stuffing bits...
///     @ 0x0A028 MAC_CLK_CTRL         (RW)
///               ###
///               * PCIE MAC clock control register
///               ###
///               %unsigned 1  AXI_CLKEN                 0x1
///                                    ###
///                                    * AXI clock enable
///                                    * 0: CLK is not enabled (OFF )
///                                    * 1: CLK is enabled (ON)
///                                    ###
///               %unsigned 1  AHB_CLKEN                 0x1
///                                    ###
///                                    * AHB clock enable
///                                    * 0: CLK is not enabled (OFF )
///                                    * 1: CLK is enabled (ON)
///                                    ###
///               %unsigned 1  CORE_CLKEN                0x1
///                                    ###
///                                    * PCIE Core clock enable
///                                    * 0: CLK is not enabled (OFF )
///                                    * 1: CLK is enabled (ON)
///                                    ###
///               %unsigned 1  PIPE_CLKEN                0x1
///                                    ###
///                                    * PPIE clock enable
///                                    * 0: CLK is not enabled (OFF )
///                                    * 1: CLK is enabled (ON)
///                                    ###
///               %%        28         # Stuffing bits...
///     @ 0x0A02C                      (P)
///     # 0x0A02C REFCLK
///               $REFCLK              REFCLK            REG
///                                    ###
///                                    * Reference clock buffer control registers
///                                    ###
///     @ 0x0A038 PHY_CTRL_CMN         (RW)
///               ###
///               * PHY control register for common signals
///               ###
///               %unsigned 1  TEST_PDOWN                0x0
///                                    ###
///                                    * Power down signal for PHY to use for testing to measure IDDQ
///                                    ###
///               %unsigned 1  TEST_BURNIN               0x0
///                                    ###
///                                    * Test Burnin Signal
///                                    ###
///               %unsigned 1  TEST_BYPASS               0x0
///                                    ###
///                                    * Test Bypass Signal
///                                    ###
///               %unsigned 1  REF_USE_PAD               0x0
///                                    ###
///                                    * RefClock source selection
///                                    * 0: Internal CMOS REFCLK
///                                    * 1: REFCLK from PAD (Inside PHY)
///                                    * 0
///                                    ###
///               %unsigned 1  REF_CLK_DIV2              0x0
///                                    ###
///                                    * Reference clock divide by 2
///                                    * 0: No divide
///                                    * 1: Divide by 2
///                                    ###
///               %unsigned 7  REF_CLK_MPLL_MULT         0x19
///                                    ###
///                                    * Reference clock Multiplier setting
///                                    ###
///               %unsigned 1  RTUNE_REQ                 0x0
///                                    ###
///                                    * Manual Request for Resistor Tuning
///                                    ###
///               %unsigned 5  ACJT_LEVEL                0x0
///                                    ###
///                                    * AC JTAG Level
///                                    ###
///               %unsigned 2  PORT_SEL                  0x1
///                                    ###
///                                    * PIPE Port selection
///                                    * 2'b01 : x2 PIPE
///                                    * 2'b10 : x1 PIPE
///                                    * Others reserved
///                                    ###
///               %unsigned 1  VREG_BYPASS               0x1
///                                    ###
///                                    * Regulator Bypass
///                                    * 0: Use regulator
///                                    * 1: Bypass
///                                    ###
///               %unsigned 1  COMMON_CLOCKS             0x1
///                                    ###
///                                    * Select Common Clock Mode for Receive Datapath When both ends of a PCIe link share a common reference clock, the latency through the receiver's elasticity buffer can be shorter,
///                                    * because no frequency offset exists between the two ends of the link.
///                                    * 0: Reference clock not common
///                                    * 1: Common reference clock
///                                    ###
///               %unsigned 1  RX_EI_DISABLE             0x0
///                                    ###
///                                    * Disable PIPE Receiver Electrical Idle Detection Circuit. Disables the RX electrical idle detection circuit as required by the L1.1 and L1.2 substates. This signal also forces pipe_rxN_elecidle high until the detector is enabled again.
///                                    * 0: Enable RX electrical idle detection.
///                                    * 1: Disable RX electrical idle detection.
///                                    ###
///               %unsigned 1  TX_CM_DISABLE             0x0
///                                    ###
///                                    * Disables the TX common mode
///                                    * Disables the TX common mode hold circuit to comply with the low power goals of the L1.2 substate.
///                                    * 0: Enable TX common mode.
///                                    * 1: Disable TX common mode.
///                                    ###
///               %unsigned 1  TX2RX_LOOPBK              0x0
///                                    ###
///                                    * TX-to-RX Loopback Enable When this signal is asserted, data from the transmit predriver is looped back to the receive slicers. LOS is bypassed and based on the txN_en input so that rxN_los = !txN_data_en.
///                                    * 0: Loopback is disabled (normal operation).
///                                    * 1: Loopback is enabled.
///                                    ###
///               %%        7          # Stuffing bits...
///     @ 0x0A03C PHY_CTRL0            (RW)
///               ###
///               * PHY control register 0
///               ###
///               %unsigned 3  PHY_LOS_BIAS              0x2
///                                    ###
///                                    * LOS Signal detector threshold contol in +/-15mv steps
///                                    ###
///               %unsigned 5  PHY_LOS_LEVEL             0x9
///                                    ###
///                                    * LOS signal sensitivity level control
///                                    ###
///               %unsigned 3  RX0_EQ                    0x2
///                                    ###
///                                    * RX Equalizer setting for Lane 0
///                                    ###
///               %unsigned 3  RX1_EQ                    0x2
///                                    ###
///                                    * RX Equalizer setting for Lane 1
///                                    ###
///               %unsigned 6  TX_DEEMPH_GEN1            0x16
///                                    ###
///                                    * TX De-emphasis at Gen1
///                                    ###
///               %unsigned 6  TX_DEEMPH_GEN2_3P5        0x16
///                                    ###
///                                    * TX De-emphasis at Gen2 3.5db
///                                    ###
///               %unsigned 6  TX_DEEMPH_GEN2_6          0x21
///                                    ###
///                                    * TX De-emphasis at Gen2 6db
///                                    ###
///     @ 0x0A040 PHY_CTRL1            (RW)
///               %unsigned 7  TX_SWING_FULL             0x78
///                                    ###
///                                    * TX Amplitude (Full Swing Mode)
///                                    ###
///               %unsigned 7  TX_SWING_LOW              0x78
///                                    ###
///                                    * TX Amplitude (Low Swing Mode)
///                                    ###
///               %unsigned 5  TX0_TERM_OFFSET           0x0
///                                    ###
///                                    * Transmitter Ln0 Termination Offset
///                                    * Enables adjustment of the transmitter termination value from the default value of 50 ohms.
///                                    ###
///               %unsigned 5  TX1_TERM_OFFSET           0x0
///                                    ###
///                                    * Transmitter Ln1 Termination Offset
///                                    * Enables adjustment of the transmitter termination value from the default value of 50 ohms.
///                                    ###
///               %unsigned 3  TX_VBOOST_LVL             0x4
///                                    ###
///                                    * TX Voltage Boost Level
///                                    * Controls the launch amplitude only when VPTX is less than the
///                                    * launch amplitude corresponding to tx_vboost_lvl. Valid settings for
///                                    * tx_vboost_lvl[2:0]:
///                                    * 011: Corresponds to a launch amplitude of 0.844 V.
///                                    * 100 (default): Corresponds to a launch amplitude of 1 V.
///                                    * 101: Corresponds to a launch amplitude of 1.156 V.
///                                    ###
///               %%        5          # Stuffing bits...
///     @ 0x0A044 PHY_STS0             (R-)
///               ###
///               * PHY outputs here for status Read Only
///               ###
///               %unsigned 1  RTUNE_ACK
///                                    ###
///                                    * Indicates the completion of Resistance tuning.
///                                    ###
///               %%        31         # Stuffing bits...
///     @ 0x0A048 HWDBG_CTRL           (RW)
///               ###
///               * Hardware Debug control. This register is used to select the Debug Bus coming out of the PCIE subsystem to the chip pins.
///               ###
///               %unsigned 2  PCIESEL                   0x0
///                                    ###
///                                    * Bit used to select which PCIE debug bus needs to be selected to be observed on the Chip debug port
///                                    * 0 : PCIE 0 (x2 MAC)
///                                    * 1 : PCIE 1 (x1 MAC)
///                                    * 2 : PCIE 2 (x1 MAC)
///                                    * Note: Only PCIE0 register bits are used others are not used
///                                    ###
///               %unsigned 1  DATASEL                   0x0
///                                    ###
///                                    * Bit to select the upper or lower 16-bits of the debug data.
///                                    * 0: Selects the [15:0] data
///                                    * 1: Selects the [31:16] data
///                                    * Note: Only PCIE0 register bits are used others are not used
///                                    ###
///               %unsigned 8  SIGSEL                    0x0
///                                    ###
///                                    * These bits selects the debug signals from each PCIE IP.
///                                    * Note: All the PCIE0/1/2 register bits are used since the debug data from all the 3 PCIE is stored in the HWDBG_DATA regitser
///                                    ###
///               %%        21         # Stuffing bits...
///     @ 0x0A04C HWDBG_DATA           (R-)
///               ###
///               * Debug data from IP
///               ###
///               %unsigned 32 VAL
///     @ 0x0A050 AXI_LIMIT_LOWER      (RW)
///               %unsigned 32 ADDR_FILTER_LOWER         0x0
///                                    ###
///                                    * The lower bound for PCIe AXI memory access. PCIe will be denied and hang if its AXI address is less than this register's value, regardless of AXI write or AXI read.
///                                    ###
///     @ 0x0A054 AXI_LIMIT_UPPER      (RW)
///               %unsigned 32 ADDR_FILTER_UPPER         0x0
///                                    ###
///                                    * The upper bound for PCIe AXI memory access. PCIe will be denied and hang if its AXI address is greater than this register's value, regardless of AXI write or AXI read.
///                                    ###
///     @ 0x0A058 SPARE_0              (RW)
///               %unsigned 32 REGBITS                   0x0
///     @ 0x0A05C SPARE_1              (RW)
///               %unsigned 32 REGBITS                   0x0
///     @ 0x0A060 SPARE_2              (RW)
///               %unsigned 32 REGBITS                   0x0
///     @ 0x0A064 SPARE_3              (RW)
///               %unsigned 32 REGBITS                   0x0
///                                    ###
///                                    * **INTERNAL_ONLY**
///                                    * Spare register bits for future use
///                                    ###
///     @ 0x0A068                      (W-)
///     #         # Stuffing bytes...
///               %% 195776
///     # # ----------------------------------------------------------
/// $ENDOFINTERFACE  # size:   65536B, bits:     676b, padding:     0B
////////////////////////////////////////////////////////////
#ifndef h_PCIE
#define h_PCIE (){}

    #define     RA_PCIE_IP_REGSP_0                             0x0000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_IP_REGSP_1                             0x8000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MSI_INTR_RX                            0xA000

    #define     BA_PCIE_MSI_INTR_RX_DATA                       0xA000
    #define     B16PCIE_MSI_INTR_RX_DATA                       0xA000
    #define   LSb32PCIE_MSI_INTR_RX_DATA                          0
    #define   LSb16PCIE_MSI_INTR_RX_DATA                          0
    #define       bPCIE_MSI_INTR_RX_DATA                       32
    #define   MSK32PCIE_MSI_INTR_RX_DATA                          0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MSI_INTR_STATUS                        0xA004

    #define     BA_PCIE_MSI_INTR_STATUS_VALUE                  0xA004
    #define     B16PCIE_MSI_INTR_STATUS_VALUE                  0xA004
    #define   LSb32PCIE_MSI_INTR_STATUS_VALUE                     0
    #define   LSb16PCIE_MSI_INTR_STATUS_VALUE                     0
    #define       bPCIE_MSI_INTR_STATUS_VALUE                  32
    #define   MSK32PCIE_MSI_INTR_STATUS_VALUE                     0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MSI_INTR_MASK                          0xA008

    #define     BA_PCIE_MSI_INTR_MASK_VALUE                    0xA008
    #define     B16PCIE_MSI_INTR_MASK_VALUE                    0xA008
    #define   LSb32PCIE_MSI_INTR_MASK_VALUE                       0
    #define   LSb16PCIE_MSI_INTR_MASK_VALUE                       0
    #define       bPCIE_MSI_INTR_MASK_VALUE                    32
    #define   MSK32PCIE_MSI_INTR_MASK_VALUE                       0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_INTR_STATUS                        0xA00C

    #define     BA_PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR           0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR           0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR              0
    #define   LSb16PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR              0
    #define       bPCIE_MAC_INTR_STATUS_AXI_ADDR_OOR           1
    #define   MSK32PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR              0x00000001

    #define     BA_PCIE_MAC_INTR_STATUS_MSI_CTRL_INT           0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_MSI_CTRL_INT           0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_MSI_CTRL_INT              1
    #define   LSb16PCIE_MAC_INTR_STATUS_MSI_CTRL_INT              1
    #define       bPCIE_MAC_INTR_STATUS_MSI_CTRL_INT           1
    #define   MSK32PCIE_MAC_INTR_STATUS_MSI_CTRL_INT              0x00000002

    #define     BA_PCIE_MAC_INTR_STATUS_HP_INT                 0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_HP_INT                 0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_HP_INT                    2
    #define   LSb16PCIE_MAC_INTR_STATUS_HP_INT                    2
    #define       bPCIE_MAC_INTR_STATUS_HP_INT                 1
    #define   MSK32PCIE_MAC_INTR_STATUS_HP_INT                    0x00000004

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_PME_INT            0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_CFG_PME_INT            0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_PME_INT               3
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_PME_INT               3
    #define       bPCIE_MAC_INTR_STATUS_CFG_PME_INT            1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_PME_INT               0x00000008

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT     0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT     0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT        4
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT        4
    #define       bPCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT     1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT        0x00000010

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI     0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI     0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI        5
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI        5
    #define       bPCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI     1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI        0x00000020

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC         0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC         0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC            6
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC            6
    #define       bPCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC         1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC            0x00000040

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_PME_MSI            0xA00C
    #define     B16PCIE_MAC_INTR_STATUS_CFG_PME_MSI            0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_PME_MSI               7
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_PME_MSI               7
    #define       bPCIE_MAC_INTR_STATUS_CFG_PME_MSI            1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_PME_MSI               0x00000080

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR   0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR   0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR      8
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR      8
    #define       bPCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR   1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR      0x00000100

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR      0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR      0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR         9
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR         9
    #define       bPCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR      1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR         0x00000200

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR         0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR         0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR            10
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR            10
    #define       bPCIE_MAC_INTR_STATUS_RADM_FATAL_ERR         1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR            0x00000400

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_PM_PME            0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_RADM_PM_PME            0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_PM_PME               11
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_PM_PME               11
    #define       bPCIE_MAC_INTR_STATUS_RADM_PM_PME            1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_PM_PME               0x00000800

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK         0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK         0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK            12
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK            12
    #define       bPCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK         1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK            0x00001000

    #define     BA_PCIE_MAC_INTR_STATUS_HP_PME                 0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_HP_PME                 0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_HP_PME                    13
    #define   LSb16PCIE_MAC_INTR_STATUS_HP_PME                    13
    #define       bPCIE_MAC_INTR_STATUS_HP_PME                 1
    #define   MSK32PCIE_MAC_INTR_STATUS_HP_PME                    0x00002000

    #define     BA_PCIE_MAC_INTR_STATUS_HP_MSI                 0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_HP_MSI                 0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_HP_MSI                    14
    #define   LSb16PCIE_MAC_INTR_STATUS_HP_MSI                    14
    #define       bPCIE_MAC_INTR_STATUS_HP_MSI                 1
    #define   MSK32PCIE_MAC_INTR_STATUS_HP_MSI                    0x00004000

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT   0xA00D
    #define     B16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT   0xA00C
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT      15
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT      15
    #define       bPCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT   1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT      0x00008000

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI   0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI   0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI      16
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI      0
    #define       bPCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI   1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI      0x00010000

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT         0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT         0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT            17
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT            1
    #define       bPCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT         1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT            0x00020000

    #define     BA_PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI         0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI         0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI            18
    #define   LSb16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI            2
    #define       bPCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI         1
    #define   MSK32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI            0x00040000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED     0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED     0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED        19
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED        3
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED     1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED        0x00080000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED     0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED     0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED        20
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED        4
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED     1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED        0x00100000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED     0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED     0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED        21
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED        5
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED     1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED        0x00200000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED     0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED     0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED        22
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED        6
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED     1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED        0x00400000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED   0xA00E
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED   0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED      23
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED      7
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED   1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED      0x00800000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED   0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED   0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED      24
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED      8
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED   1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED      0x01000000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED   0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED   0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED      25
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED      9
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED   1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED      0x02000000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED   0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED   0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED      26
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED      10
    #define       bPCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED   1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED      0x04000000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW         0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW         0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW            27
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW            11
    #define       bPCIE_MAC_INTR_STATUS_RADM_QOVERFLOW         1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW            0x08000000

    #define     BA_PCIE_MAC_INTR_STATUS_SMLH_LINK_UP           0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_SMLH_LINK_UP           0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_SMLH_LINK_UP              28
    #define   LSb16PCIE_MAC_INTR_STATUS_SMLH_LINK_UP              12
    #define       bPCIE_MAC_INTR_STATUS_SMLH_LINK_UP           1
    #define   MSK32PCIE_MAC_INTR_STATUS_SMLH_LINK_UP              0x10000000

    #define     BA_PCIE_MAC_INTR_STATUS_SMLH_LINK_DN           0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_SMLH_LINK_DN           0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_SMLH_LINK_DN              29
    #define   LSb16PCIE_MAC_INTR_STATUS_SMLH_LINK_DN              13
    #define       bPCIE_MAC_INTR_STATUS_SMLH_LINK_DN           1
    #define   MSK32PCIE_MAC_INTR_STATUS_SMLH_LINK_DN              0x20000000

    #define     BA_PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT       0xA00F
    #define     B16PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT       0xA00E
    #define   LSb32PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT          30
    #define   LSb16PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT          14
    #define       bPCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT       1
    #define   MSK32PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT          0x40000000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_INTR_MASK                          0xA010

    #define     BA_PCIE_MAC_INTR_MASK_INTR_MASK                0xA010
    #define     B16PCIE_MAC_INTR_MASK_INTR_MASK                0xA010
    #define   LSb32PCIE_MAC_INTR_MASK_INTR_MASK                   0
    #define   LSb16PCIE_MAC_INTR_MASK_INTR_MASK                   0
    #define       bPCIE_MAC_INTR_MASK_INTR_MASK                32
    #define   MSK32PCIE_MAC_INTR_MASK_INTR_MASK                   0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_INTR_STATUS1                       0xA014

    #define     BA_PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH 0xA014
    #define     B16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH 0xA014
    #define   LSb32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH    0
    #define   LSb16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH    0
    #define       bPCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH 1
    #define   MSK32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH    0x00000001

    #define     BA_PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR 0xA014
    #define     B16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR 0xA014
    #define   LSb32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR    1
    #define   LSb16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR    1
    #define       bPCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR 1
    #define   MSK32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR    0x00000002

    #define     BA_PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH 0xA014
    #define     B16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH 0xA014
    #define   LSb32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH    2
    #define   LSb16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH    2
    #define       bPCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH 1
    #define   MSK32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH    0x00000004

    #define     BA_PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR 0xA014
    #define     B16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR 0xA014
    #define   LSb32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR    3
    #define   LSb16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR    3
    #define       bPCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR 1
    #define   MSK32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR    0x00000008
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_INTR_MASK1                         0xA018

    #define     BA_PCIE_MAC_INTR_MASK1_INTR_MASK1              0xA018
    #define     B16PCIE_MAC_INTR_MASK1_INTR_MASK1              0xA018
    #define   LSb32PCIE_MAC_INTR_MASK1_INTR_MASK1                 0
    #define   LSb16PCIE_MAC_INTR_MASK1_INTR_MASK1                 0
    #define       bPCIE_MAC_INTR_MASK1_INTR_MASK1              32
    #define   MSK32PCIE_MAC_INTR_MASK1_INTR_MASK1                 0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_CTRL                               0xA01C

    #define     BA_PCIE_MAC_CTRL_SYSWREQ                       0xA01C
    #define     B16PCIE_MAC_CTRL_SYSWREQ                       0xA01C
    #define   LSb32PCIE_MAC_CTRL_SYSWREQ                          0
    #define   LSb16PCIE_MAC_CTRL_SYSWREQ                          0
    #define       bPCIE_MAC_CTRL_SYSWREQ                       1
    #define   MSK32PCIE_MAC_CTRL_SYSWREQ                          0x00000001

    #define     BA_PCIE_MAC_CTRL_CPU_INTERFACE_SEL             0xA01C
    #define     B16PCIE_MAC_CTRL_CPU_INTERFACE_SEL             0xA01C
    #define   LSb32PCIE_MAC_CTRL_CPU_INTERFACE_SEL                1
    #define   LSb16PCIE_MAC_CTRL_CPU_INTERFACE_SEL                1
    #define       bPCIE_MAC_CTRL_CPU_INTERFACE_SEL             1
    #define   MSK32PCIE_MAC_CTRL_CPU_INTERFACE_SEL                0x00000002

    #define     BA_PCIE_MAC_CTRL_CFG_TYPE                      0xA01C
    #define     B16PCIE_MAC_CTRL_CFG_TYPE                      0xA01C
    #define   LSb32PCIE_MAC_CTRL_CFG_TYPE                         2
    #define   LSb16PCIE_MAC_CTRL_CFG_TYPE                         2
    #define       bPCIE_MAC_CTRL_CFG_TYPE                      1
    #define   MSK32PCIE_MAC_CTRL_CFG_TYPE                         0x00000004

    #define     BA_PCIE_MAC_CTRL_MEMMAP_CFG_VALID              0xA01C
    #define     B16PCIE_MAC_CTRL_MEMMAP_CFG_VALID              0xA01C
    #define   LSb32PCIE_MAC_CTRL_MEMMAP_CFG_VALID                 3
    #define   LSb16PCIE_MAC_CTRL_MEMMAP_CFG_VALID                 3
    #define       bPCIE_MAC_CTRL_MEMMAP_CFG_VALID              1
    #define   MSK32PCIE_MAC_CTRL_MEMMAP_CFG_VALID                 0x00000008

    #define     BA_PCIE_MAC_CTRL_SYS_AUX_PWR_DET               0xA01C
    #define     B16PCIE_MAC_CTRL_SYS_AUX_PWR_DET               0xA01C
    #define   LSb32PCIE_MAC_CTRL_SYS_AUX_PWR_DET                  4
    #define   LSb16PCIE_MAC_CTRL_SYS_AUX_PWR_DET                  4
    #define       bPCIE_MAC_CTRL_SYS_AUX_PWR_DET               1
    #define   MSK32PCIE_MAC_CTRL_SYS_AUX_PWR_DET                  0x00000010

    #define     BA_PCIE_MAC_CTRL_APP_LTSSM_ENABLE              0xA01C
    #define     B16PCIE_MAC_CTRL_APP_LTSSM_ENABLE              0xA01C
    #define   LSb32PCIE_MAC_CTRL_APP_LTSSM_ENABLE                 5
    #define   LSb16PCIE_MAC_CTRL_APP_LTSSM_ENABLE                 5
    #define       bPCIE_MAC_CTRL_APP_LTSSM_ENABLE              1
    #define   MSK32PCIE_MAC_CTRL_APP_LTSSM_ENABLE                 0x00000020

    #define     BA_PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN 0xA01C
    #define     B16PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN 0xA01C
    #define   LSb32PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN    6
    #define   LSb16PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN    6
    #define       bPCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN 1
    #define   MSK32PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN    0x00000040

    #define     BA_PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN 0xA01C
    #define     B16PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN 0xA01C
    #define   LSb32PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN    7
    #define   LSb16PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN    7
    #define       bPCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN 1
    #define   MSK32PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN    0x00000080

    #define     BA_PCIE_MAC_CTRL_ADDR_FILTER_FLAG              0xA01D
    #define     B16PCIE_MAC_CTRL_ADDR_FILTER_FLAG              0xA01C
    #define   LSb32PCIE_MAC_CTRL_ADDR_FILTER_FLAG                 8
    #define   LSb16PCIE_MAC_CTRL_ADDR_FILTER_FLAG                 8
    #define       bPCIE_MAC_CTRL_ADDR_FILTER_FLAG              1
    #define   MSK32PCIE_MAC_CTRL_ADDR_FILTER_FLAG                 0x00000100

    #define     BA_PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N          0xA01D
    #define     B16PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N          0xA01C
    #define   LSb32PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N             9
    #define   LSb16PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N             9
    #define       bPCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N          1
    #define   MSK32PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N             0x00000200

    #define     BA_PCIE_MAC_CTRL_CLK_RST_BYPASS                0xA01D
    #define     B16PCIE_MAC_CTRL_CLK_RST_BYPASS                0xA01C
    #define   LSb32PCIE_MAC_CTRL_CLK_RST_BYPASS                   10
    #define   LSb16PCIE_MAC_CTRL_CLK_RST_BYPASS                   10
    #define       bPCIE_MAC_CTRL_CLK_RST_BYPASS                1
    #define   MSK32PCIE_MAC_CTRL_CLK_RST_BYPASS                   0x00000400

    #define     BA_PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE            0xA01D
    #define     B16PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE            0xA01C
    #define   LSb32PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE               11
    #define   LSb16PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE               11
    #define       bPCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE            1
    #define   MSK32PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE               0x00000800

    #define     BA_PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL         0xA01D
    #define     B16PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL         0xA01C
    #define   LSb32PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL            12
    #define   LSb16PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL            12
    #define       bPCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL         1
    #define   MSK32PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL            0x00001000

    #define     BA_PCIE_MAC_CTRL_APP_CLK_REQ_N                 0xA01D
    #define     B16PCIE_MAC_CTRL_APP_CLK_REQ_N                 0xA01C
    #define   LSb32PCIE_MAC_CTRL_APP_CLK_REQ_N                    13
    #define   LSb16PCIE_MAC_CTRL_APP_CLK_REQ_N                    13
    #define       bPCIE_MAC_CTRL_APP_CLK_REQ_N                 1
    #define   MSK32PCIE_MAC_CTRL_APP_CLK_REQ_N                    0x00002000

    #define     BA_PCIE_MAC_CTRL_APP_REQ_EXIT_L1               0xA01D
    #define     B16PCIE_MAC_CTRL_APP_REQ_EXIT_L1               0xA01C
    #define   LSb32PCIE_MAC_CTRL_APP_REQ_EXIT_L1                  14
    #define   LSb16PCIE_MAC_CTRL_APP_REQ_EXIT_L1                  14
    #define       bPCIE_MAC_CTRL_APP_REQ_EXIT_L1               1
    #define   MSK32PCIE_MAC_CTRL_APP_REQ_EXIT_L1                  0x00004000

    #define     BA_PCIE_MAC_CTRL_APP_XFER_PENDING              0xA01D
    #define     B16PCIE_MAC_CTRL_APP_XFER_PENDING              0xA01C
    #define   LSb32PCIE_MAC_CTRL_APP_XFER_PENDING                 15
    #define   LSb16PCIE_MAC_CTRL_APP_XFER_PENDING                 15
    #define       bPCIE_MAC_CTRL_APP_XFER_PENDING              1
    #define   MSK32PCIE_MAC_CTRL_APP_XFER_PENDING                 0x00008000

    #define     BA_PCIE_MAC_CTRL_APP_CLK_PM_EN                 0xA01E
    #define     B16PCIE_MAC_CTRL_APP_CLK_PM_EN                 0xA01E
    #define   LSb32PCIE_MAC_CTRL_APP_CLK_PM_EN                    16
    #define   LSb16PCIE_MAC_CTRL_APP_CLK_PM_EN                    0
    #define       bPCIE_MAC_CTRL_APP_CLK_PM_EN                 1
    #define   MSK32PCIE_MAC_CTRL_APP_CLK_PM_EN                    0x00010000

    #define     BA_PCIE_MAC_CTRL_PIPE2PIPE_BYPASS              0xA01E
    #define     B16PCIE_MAC_CTRL_PIPE2PIPE_BYPASS              0xA01E
    #define   LSb32PCIE_MAC_CTRL_PIPE2PIPE_BYPASS                 17
    #define   LSb16PCIE_MAC_CTRL_PIPE2PIPE_BYPASS                 1
    #define       bPCIE_MAC_CTRL_PIPE2PIPE_BYPASS              1
    #define   MSK32PCIE_MAC_CTRL_PIPE2PIPE_BYPASS                 0x00020000

    #define     BA_PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF           0xA01E
    #define     B16PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF           0xA01E
    #define   LSb32PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF              18
    #define   LSb16PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF              2
    #define       bPCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF           1
    #define   MSK32PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF              0x00040000

    #define     BA_PCIE_MAC_CTRL_CLEAR_L2_INTR                 0xA01E
    #define     B16PCIE_MAC_CTRL_CLEAR_L2_INTR                 0xA01E
    #define   LSb32PCIE_MAC_CTRL_CLEAR_L2_INTR                    19
    #define   LSb16PCIE_MAC_CTRL_CLEAR_L2_INTR                    3
    #define       bPCIE_MAC_CTRL_CLEAR_L2_INTR                 1
    #define   MSK32PCIE_MAC_CTRL_CLEAR_L2_INTR                    0x00080000

    #define     BA_PCIE_MAC_CTRL_SLV_WMISC_INFO                0xA01E
    #define     B16PCIE_MAC_CTRL_SLV_WMISC_INFO                0xA01E
    #define   LSb32PCIE_MAC_CTRL_SLV_WMISC_INFO                   20
    #define   LSb16PCIE_MAC_CTRL_SLV_WMISC_INFO                   4
    #define       bPCIE_MAC_CTRL_SLV_WMISC_INFO                1
    #define   MSK32PCIE_MAC_CTRL_SLV_WMISC_INFO                   0x00100000

    #define     BA_PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS             0xA01E
    #define     B16PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS             0xA01E
    #define   LSb32PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS                21
    #define   LSb16PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS                5
    #define       bPCIE_MAC_CTRL_APP_DBI_RO_WR_DIS             1
    #define   MSK32PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS                0x00200000

    #define     BA_PCIE_MAC_CTRL_RX_LANE_FLIP_EN               0xA01E
    #define     B16PCIE_MAC_CTRL_RX_LANE_FLIP_EN               0xA01E
    #define   LSb32PCIE_MAC_CTRL_RX_LANE_FLIP_EN                  22
    #define   LSb16PCIE_MAC_CTRL_RX_LANE_FLIP_EN                  6
    #define       bPCIE_MAC_CTRL_RX_LANE_FLIP_EN               1
    #define   MSK32PCIE_MAC_CTRL_RX_LANE_FLIP_EN                  0x00400000

    #define     BA_PCIE_MAC_CTRL_TX_LANE_FLIP_EN               0xA01E
    #define     B16PCIE_MAC_CTRL_TX_LANE_FLIP_EN               0xA01E
    #define   LSb32PCIE_MAC_CTRL_TX_LANE_FLIP_EN                  23
    #define   LSb16PCIE_MAC_CTRL_TX_LANE_FLIP_EN                  7
    #define       bPCIE_MAC_CTRL_TX_LANE_FLIP_EN               1
    #define   MSK32PCIE_MAC_CTRL_TX_LANE_FLIP_EN                  0x00800000

    #define     BA_PCIE_MAC_CTRL_APP_HOLD_PHY_RST              0xA01F
    #define     B16PCIE_MAC_CTRL_APP_HOLD_PHY_RST              0xA01E
    #define   LSb32PCIE_MAC_CTRL_APP_HOLD_PHY_RST                 24
    #define   LSb16PCIE_MAC_CTRL_APP_HOLD_PHY_RST                 8
    #define       bPCIE_MAC_CTRL_APP_HOLD_PHY_RST              1
    #define   MSK32PCIE_MAC_CTRL_APP_HOLD_PHY_RST                 0x01000000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_STATUS                             0xA020

    #define     BA_PCIE_MAC_STATUS_DWACK                       0xA020
    #define     B16PCIE_MAC_STATUS_DWACK                       0xA020
    #define   LSb32PCIE_MAC_STATUS_DWACK                          0
    #define   LSb16PCIE_MAC_STATUS_DWACK                          0
    #define       bPCIE_MAC_STATUS_DWACK                       1
    #define   MSK32PCIE_MAC_STATUS_DWACK                          0x00000001

    #define     BA_PCIE_MAC_STATUS_RDLH_LINK_UP                0xA020
    #define     B16PCIE_MAC_STATUS_RDLH_LINK_UP                0xA020
    #define   LSb32PCIE_MAC_STATUS_RDLH_LINK_UP                   1
    #define   LSb16PCIE_MAC_STATUS_RDLH_LINK_UP                   1
    #define       bPCIE_MAC_STATUS_RDLH_LINK_UP                1
    #define   MSK32PCIE_MAC_STATUS_RDLH_LINK_UP                   0x00000002

    #define     BA_PCIE_MAC_STATUS_PM_CURNT_STATE              0xA020
    #define     B16PCIE_MAC_STATUS_PM_CURNT_STATE              0xA020
    #define   LSb32PCIE_MAC_STATUS_PM_CURNT_STATE                 2
    #define   LSb16PCIE_MAC_STATUS_PM_CURNT_STATE                 2
    #define       bPCIE_MAC_STATUS_PM_CURNT_STATE              3
    #define   MSK32PCIE_MAC_STATUS_PM_CURNT_STATE                 0x0000001C

    #define     BA_PCIE_MAC_STATUS_SMLH_LTSSM_STATE            0xA020
    #define     B16PCIE_MAC_STATUS_SMLH_LTSSM_STATE            0xA020
    #define   LSb32PCIE_MAC_STATUS_SMLH_LTSSM_STATE               5
    #define   LSb16PCIE_MAC_STATUS_SMLH_LTSSM_STATE               5
    #define       bPCIE_MAC_STATUS_SMLH_LTSSM_STATE            6
    #define   MSK32PCIE_MAC_STATUS_SMLH_LTSSM_STATE               0x000007E0

    #define     BA_PCIE_MAC_STATUS_SMLH_LINK_UP                0xA021
    #define     B16PCIE_MAC_STATUS_SMLH_LINK_UP                0xA020
    #define   LSb32PCIE_MAC_STATUS_SMLH_LINK_UP                   11
    #define   LSb16PCIE_MAC_STATUS_SMLH_LINK_UP                   11
    #define       bPCIE_MAC_STATUS_SMLH_LINK_UP                1
    #define   MSK32PCIE_MAC_STATUS_SMLH_LINK_UP                   0x00000800

    #define     BA_PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY            0xA021
    #define     B16PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY            0xA020
    #define   LSb32PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY               12
    #define   LSb16PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY               12
    #define       bPCIE_MAC_STATUS_RADM_Q_NOT_EMPTY            1
    #define   MSK32PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY               0x00001000

    #define     BA_PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT            0xA021
    #define     B16PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT            0xA020
    #define   LSb32PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT               13
    #define   LSb16PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT               13
    #define       bPCIE_MAC_STATUS_TRGT_CPL_TIMEOUT            1
    #define   MSK32PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT               0x00002000

    #define     BA_PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP           0xA021
    #define     B16PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP           0xA020
    #define   LSb32PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP              14
    #define   LSb16PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP              14
    #define       bPCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP           1
    #define   MSK32PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP              0x00004000

    #define     BA_PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING       0xA021
    #define     B16PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING       0xA020
    #define   LSb32PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING          15
    #define   LSb16PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING          15
    #define       bPCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING       1
    #define   MSK32PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING          0x00008000

    #define     BA_PCIE_MAC_STATUS_RADM_CPL_TIMEOUT            0xA022
    #define     B16PCIE_MAC_STATUS_RADM_CPL_TIMEOUT            0xA022
    #define   LSb32PCIE_MAC_STATUS_RADM_CPL_TIMEOUT               16
    #define   LSb16PCIE_MAC_STATUS_RADM_CPL_TIMEOUT               0
    #define       bPCIE_MAC_STATUS_RADM_CPL_TIMEOUT            1
    #define   MSK32PCIE_MAC_STATUS_RADM_CPL_TIMEOUT               0x00010000

    #define     BA_PCIE_MAC_STATUS_CFG_INT_PIN                 0xA022
    #define     B16PCIE_MAC_STATUS_CFG_INT_PIN                 0xA022
    #define   LSb32PCIE_MAC_STATUS_CFG_INT_PIN                    17
    #define   LSb16PCIE_MAC_STATUS_CFG_INT_PIN                    1
    #define       bPCIE_MAC_STATUS_CFG_INT_PIN                 8
    #define   MSK32PCIE_MAC_STATUS_CFG_INT_PIN                    0x01FE0000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_RID_REG                            0xA024

    #define     BA_PCIE_MAC_RID_REG_BUS_NUM                    0xA024
    #define     B16PCIE_MAC_RID_REG_BUS_NUM                    0xA024
    #define   LSb32PCIE_MAC_RID_REG_BUS_NUM                       0
    #define   LSb16PCIE_MAC_RID_REG_BUS_NUM                       0
    #define       bPCIE_MAC_RID_REG_BUS_NUM                    8
    #define   MSK32PCIE_MAC_RID_REG_BUS_NUM                       0x000000FF

    #define     BA_PCIE_MAC_RID_REG_DEV_NUM                    0xA025
    #define     B16PCIE_MAC_RID_REG_DEV_NUM                    0xA024
    #define   LSb32PCIE_MAC_RID_REG_DEV_NUM                       8
    #define   LSb16PCIE_MAC_RID_REG_DEV_NUM                       8
    #define       bPCIE_MAC_RID_REG_DEV_NUM                    5
    #define   MSK32PCIE_MAC_RID_REG_DEV_NUM                       0x00001F00
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_MAC_CLK_CTRL                           0xA028

    #define     BA_PCIE_MAC_CLK_CTRL_AXI_CLKEN                 0xA028
    #define     B16PCIE_MAC_CLK_CTRL_AXI_CLKEN                 0xA028
    #define   LSb32PCIE_MAC_CLK_CTRL_AXI_CLKEN                    0
    #define   LSb16PCIE_MAC_CLK_CTRL_AXI_CLKEN                    0
    #define       bPCIE_MAC_CLK_CTRL_AXI_CLKEN                 1
    #define   MSK32PCIE_MAC_CLK_CTRL_AXI_CLKEN                    0x00000001

    #define     BA_PCIE_MAC_CLK_CTRL_AHB_CLKEN                 0xA028
    #define     B16PCIE_MAC_CLK_CTRL_AHB_CLKEN                 0xA028
    #define   LSb32PCIE_MAC_CLK_CTRL_AHB_CLKEN                    1
    #define   LSb16PCIE_MAC_CLK_CTRL_AHB_CLKEN                    1
    #define       bPCIE_MAC_CLK_CTRL_AHB_CLKEN                 1
    #define   MSK32PCIE_MAC_CLK_CTRL_AHB_CLKEN                    0x00000002

    #define     BA_PCIE_MAC_CLK_CTRL_CORE_CLKEN                0xA028
    #define     B16PCIE_MAC_CLK_CTRL_CORE_CLKEN                0xA028
    #define   LSb32PCIE_MAC_CLK_CTRL_CORE_CLKEN                   2
    #define   LSb16PCIE_MAC_CLK_CTRL_CORE_CLKEN                   2
    #define       bPCIE_MAC_CLK_CTRL_CORE_CLKEN                1
    #define   MSK32PCIE_MAC_CLK_CTRL_CORE_CLKEN                   0x00000004

    #define     BA_PCIE_MAC_CLK_CTRL_PIPE_CLKEN                0xA028
    #define     B16PCIE_MAC_CLK_CTRL_PIPE_CLKEN                0xA028
    #define   LSb32PCIE_MAC_CLK_CTRL_PIPE_CLKEN                   3
    #define   LSb16PCIE_MAC_CLK_CTRL_PIPE_CLKEN                   3
    #define       bPCIE_MAC_CLK_CTRL_PIPE_CLKEN                1
    #define   MSK32PCIE_MAC_CLK_CTRL_PIPE_CLKEN                   0x00000008
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_REFCLK                                 0xA02C
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_PHY_CTRL_CMN                           0xA038

    #define     BA_PCIE_PHY_CTRL_CMN_TEST_PDOWN                0xA038
    #define     B16PCIE_PHY_CTRL_CMN_TEST_PDOWN                0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_TEST_PDOWN                   0
    #define   LSb16PCIE_PHY_CTRL_CMN_TEST_PDOWN                   0
    #define       bPCIE_PHY_CTRL_CMN_TEST_PDOWN                1
    #define   MSK32PCIE_PHY_CTRL_CMN_TEST_PDOWN                   0x00000001

    #define     BA_PCIE_PHY_CTRL_CMN_TEST_BURNIN               0xA038
    #define     B16PCIE_PHY_CTRL_CMN_TEST_BURNIN               0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_TEST_BURNIN                  1
    #define   LSb16PCIE_PHY_CTRL_CMN_TEST_BURNIN                  1
    #define       bPCIE_PHY_CTRL_CMN_TEST_BURNIN               1
    #define   MSK32PCIE_PHY_CTRL_CMN_TEST_BURNIN                  0x00000002

    #define     BA_PCIE_PHY_CTRL_CMN_TEST_BYPASS               0xA038
    #define     B16PCIE_PHY_CTRL_CMN_TEST_BYPASS               0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_TEST_BYPASS                  2
    #define   LSb16PCIE_PHY_CTRL_CMN_TEST_BYPASS                  2
    #define       bPCIE_PHY_CTRL_CMN_TEST_BYPASS               1
    #define   MSK32PCIE_PHY_CTRL_CMN_TEST_BYPASS                  0x00000004

    #define     BA_PCIE_PHY_CTRL_CMN_REF_USE_PAD               0xA038
    #define     B16PCIE_PHY_CTRL_CMN_REF_USE_PAD               0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_REF_USE_PAD                  3
    #define   LSb16PCIE_PHY_CTRL_CMN_REF_USE_PAD                  3
    #define       bPCIE_PHY_CTRL_CMN_REF_USE_PAD               1
    #define   MSK32PCIE_PHY_CTRL_CMN_REF_USE_PAD                  0x00000008

    #define     BA_PCIE_PHY_CTRL_CMN_REF_CLK_DIV2              0xA038
    #define     B16PCIE_PHY_CTRL_CMN_REF_CLK_DIV2              0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_REF_CLK_DIV2                 4
    #define   LSb16PCIE_PHY_CTRL_CMN_REF_CLK_DIV2                 4
    #define       bPCIE_PHY_CTRL_CMN_REF_CLK_DIV2              1
    #define   MSK32PCIE_PHY_CTRL_CMN_REF_CLK_DIV2                 0x00000010

    #define     BA_PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT         0xA038
    #define     B16PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT         0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT            5
    #define   LSb16PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT            5
    #define       bPCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT         7
    #define   MSK32PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT            0x00000FE0

    #define     BA_PCIE_PHY_CTRL_CMN_RTUNE_REQ                 0xA039
    #define     B16PCIE_PHY_CTRL_CMN_RTUNE_REQ                 0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_RTUNE_REQ                    12
    #define   LSb16PCIE_PHY_CTRL_CMN_RTUNE_REQ                    12
    #define       bPCIE_PHY_CTRL_CMN_RTUNE_REQ                 1
    #define   MSK32PCIE_PHY_CTRL_CMN_RTUNE_REQ                    0x00001000

    #define     BA_PCIE_PHY_CTRL_CMN_ACJT_LEVEL                0xA039
    #define     B16PCIE_PHY_CTRL_CMN_ACJT_LEVEL                0xA038
    #define   LSb32PCIE_PHY_CTRL_CMN_ACJT_LEVEL                   13
    #define   LSb16PCIE_PHY_CTRL_CMN_ACJT_LEVEL                   13
    #define       bPCIE_PHY_CTRL_CMN_ACJT_LEVEL                5
    #define   MSK32PCIE_PHY_CTRL_CMN_ACJT_LEVEL                   0x0003E000

    #define     BA_PCIE_PHY_CTRL_CMN_PORT_SEL                  0xA03A
    #define     B16PCIE_PHY_CTRL_CMN_PORT_SEL                  0xA03A
    #define   LSb32PCIE_PHY_CTRL_CMN_PORT_SEL                     18
    #define   LSb16PCIE_PHY_CTRL_CMN_PORT_SEL                     2
    #define       bPCIE_PHY_CTRL_CMN_PORT_SEL                  2
    #define   MSK32PCIE_PHY_CTRL_CMN_PORT_SEL                     0x000C0000

    #define     BA_PCIE_PHY_CTRL_CMN_VREG_BYPASS               0xA03A
    #define     B16PCIE_PHY_CTRL_CMN_VREG_BYPASS               0xA03A
    #define   LSb32PCIE_PHY_CTRL_CMN_VREG_BYPASS                  20
    #define   LSb16PCIE_PHY_CTRL_CMN_VREG_BYPASS                  4
    #define       bPCIE_PHY_CTRL_CMN_VREG_BYPASS               1
    #define   MSK32PCIE_PHY_CTRL_CMN_VREG_BYPASS                  0x00100000

    #define     BA_PCIE_PHY_CTRL_CMN_COMMON_CLOCKS             0xA03A
    #define     B16PCIE_PHY_CTRL_CMN_COMMON_CLOCKS             0xA03A
    #define   LSb32PCIE_PHY_CTRL_CMN_COMMON_CLOCKS                21
    #define   LSb16PCIE_PHY_CTRL_CMN_COMMON_CLOCKS                5
    #define       bPCIE_PHY_CTRL_CMN_COMMON_CLOCKS             1
    #define   MSK32PCIE_PHY_CTRL_CMN_COMMON_CLOCKS                0x00200000

    #define     BA_PCIE_PHY_CTRL_CMN_RX_EI_DISABLE             0xA03A
    #define     B16PCIE_PHY_CTRL_CMN_RX_EI_DISABLE             0xA03A
    #define   LSb32PCIE_PHY_CTRL_CMN_RX_EI_DISABLE                22
    #define   LSb16PCIE_PHY_CTRL_CMN_RX_EI_DISABLE                6
    #define       bPCIE_PHY_CTRL_CMN_RX_EI_DISABLE             1
    #define   MSK32PCIE_PHY_CTRL_CMN_RX_EI_DISABLE                0x00400000

    #define     BA_PCIE_PHY_CTRL_CMN_TX_CM_DISABLE             0xA03A
    #define     B16PCIE_PHY_CTRL_CMN_TX_CM_DISABLE             0xA03A
    #define   LSb32PCIE_PHY_CTRL_CMN_TX_CM_DISABLE                23
    #define   LSb16PCIE_PHY_CTRL_CMN_TX_CM_DISABLE                7
    #define       bPCIE_PHY_CTRL_CMN_TX_CM_DISABLE             1
    #define   MSK32PCIE_PHY_CTRL_CMN_TX_CM_DISABLE                0x00800000

    #define     BA_PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK              0xA03B
    #define     B16PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK              0xA03A
    #define   LSb32PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK                 24
    #define   LSb16PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK                 8
    #define       bPCIE_PHY_CTRL_CMN_TX2RX_LOOPBK              1
    #define   MSK32PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK                 0x01000000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_PHY_CTRL0                              0xA03C

    #define     BA_PCIE_PHY_CTRL0_PHY_LOS_BIAS                 0xA03C
    #define     B16PCIE_PHY_CTRL0_PHY_LOS_BIAS                 0xA03C
    #define   LSb32PCIE_PHY_CTRL0_PHY_LOS_BIAS                    0
    #define   LSb16PCIE_PHY_CTRL0_PHY_LOS_BIAS                    0
    #define       bPCIE_PHY_CTRL0_PHY_LOS_BIAS                 3
    #define   MSK32PCIE_PHY_CTRL0_PHY_LOS_BIAS                    0x00000007

    #define     BA_PCIE_PHY_CTRL0_PHY_LOS_LEVEL                0xA03C
    #define     B16PCIE_PHY_CTRL0_PHY_LOS_LEVEL                0xA03C
    #define   LSb32PCIE_PHY_CTRL0_PHY_LOS_LEVEL                   3
    #define   LSb16PCIE_PHY_CTRL0_PHY_LOS_LEVEL                   3
    #define       bPCIE_PHY_CTRL0_PHY_LOS_LEVEL                5
    #define   MSK32PCIE_PHY_CTRL0_PHY_LOS_LEVEL                   0x000000F8

    #define     BA_PCIE_PHY_CTRL0_RX0_EQ                       0xA03D
    #define     B16PCIE_PHY_CTRL0_RX0_EQ                       0xA03C
    #define   LSb32PCIE_PHY_CTRL0_RX0_EQ                          8
    #define   LSb16PCIE_PHY_CTRL0_RX0_EQ                          8
    #define       bPCIE_PHY_CTRL0_RX0_EQ                       3
    #define   MSK32PCIE_PHY_CTRL0_RX0_EQ                          0x00000700

    #define     BA_PCIE_PHY_CTRL0_RX1_EQ                       0xA03D
    #define     B16PCIE_PHY_CTRL0_RX1_EQ                       0xA03C
    #define   LSb32PCIE_PHY_CTRL0_RX1_EQ                          11
    #define   LSb16PCIE_PHY_CTRL0_RX1_EQ                          11
    #define       bPCIE_PHY_CTRL0_RX1_EQ                       3
    #define   MSK32PCIE_PHY_CTRL0_RX1_EQ                          0x00003800

    #define     BA_PCIE_PHY_CTRL0_TX_DEEMPH_GEN1               0xA03D
    #define     B16PCIE_PHY_CTRL0_TX_DEEMPH_GEN1               0xA03C
    #define   LSb32PCIE_PHY_CTRL0_TX_DEEMPH_GEN1                  14
    #define   LSb16PCIE_PHY_CTRL0_TX_DEEMPH_GEN1                  14
    #define       bPCIE_PHY_CTRL0_TX_DEEMPH_GEN1               6
    #define   MSK32PCIE_PHY_CTRL0_TX_DEEMPH_GEN1                  0x000FC000

    #define     BA_PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5           0xA03E
    #define     B16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5           0xA03E
    #define   LSb32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5              20
    #define   LSb16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5              4
    #define       bPCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5           6
    #define   MSK32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5              0x03F00000

    #define     BA_PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6             0xA03F
    #define     B16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6             0xA03E
    #define   LSb32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6                26
    #define   LSb16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6                10
    #define       bPCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6             6
    #define   MSK32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6                0xFC000000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_PHY_CTRL1                              0xA040

    #define     BA_PCIE_PHY_CTRL1_TX_SWING_FULL                0xA040
    #define     B16PCIE_PHY_CTRL1_TX_SWING_FULL                0xA040
    #define   LSb32PCIE_PHY_CTRL1_TX_SWING_FULL                   0
    #define   LSb16PCIE_PHY_CTRL1_TX_SWING_FULL                   0
    #define       bPCIE_PHY_CTRL1_TX_SWING_FULL                7
    #define   MSK32PCIE_PHY_CTRL1_TX_SWING_FULL                   0x0000007F

    #define     BA_PCIE_PHY_CTRL1_TX_SWING_LOW                 0xA040
    #define     B16PCIE_PHY_CTRL1_TX_SWING_LOW                 0xA040
    #define   LSb32PCIE_PHY_CTRL1_TX_SWING_LOW                    7
    #define   LSb16PCIE_PHY_CTRL1_TX_SWING_LOW                    7
    #define       bPCIE_PHY_CTRL1_TX_SWING_LOW                 7
    #define   MSK32PCIE_PHY_CTRL1_TX_SWING_LOW                    0x00003F80

    #define     BA_PCIE_PHY_CTRL1_TX0_TERM_OFFSET              0xA041
    #define     B16PCIE_PHY_CTRL1_TX0_TERM_OFFSET              0xA040
    #define   LSb32PCIE_PHY_CTRL1_TX0_TERM_OFFSET                 14
    #define   LSb16PCIE_PHY_CTRL1_TX0_TERM_OFFSET                 14
    #define       bPCIE_PHY_CTRL1_TX0_TERM_OFFSET              5
    #define   MSK32PCIE_PHY_CTRL1_TX0_TERM_OFFSET                 0x0007C000

    #define     BA_PCIE_PHY_CTRL1_TX1_TERM_OFFSET              0xA042
    #define     B16PCIE_PHY_CTRL1_TX1_TERM_OFFSET              0xA042
    #define   LSb32PCIE_PHY_CTRL1_TX1_TERM_OFFSET                 19
    #define   LSb16PCIE_PHY_CTRL1_TX1_TERM_OFFSET                 3
    #define       bPCIE_PHY_CTRL1_TX1_TERM_OFFSET              5
    #define   MSK32PCIE_PHY_CTRL1_TX1_TERM_OFFSET                 0x00F80000

    #define     BA_PCIE_PHY_CTRL1_TX_VBOOST_LVL                0xA043
    #define     B16PCIE_PHY_CTRL1_TX_VBOOST_LVL                0xA042
    #define   LSb32PCIE_PHY_CTRL1_TX_VBOOST_LVL                   24
    #define   LSb16PCIE_PHY_CTRL1_TX_VBOOST_LVL                   8
    #define       bPCIE_PHY_CTRL1_TX_VBOOST_LVL                3
    #define   MSK32PCIE_PHY_CTRL1_TX_VBOOST_LVL                   0x07000000
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_PHY_STS0                               0xA044

    #define     BA_PCIE_PHY_STS0_RTUNE_ACK                     0xA044
    #define     B16PCIE_PHY_STS0_RTUNE_ACK                     0xA044
    #define   LSb32PCIE_PHY_STS0_RTUNE_ACK                        0
    #define   LSb16PCIE_PHY_STS0_RTUNE_ACK                        0
    #define       bPCIE_PHY_STS0_RTUNE_ACK                     1
    #define   MSK32PCIE_PHY_STS0_RTUNE_ACK                        0x00000001
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_HWDBG_CTRL                             0xA048

    #define     BA_PCIE_HWDBG_CTRL_PCIESEL                     0xA048
    #define     B16PCIE_HWDBG_CTRL_PCIESEL                     0xA048
    #define   LSb32PCIE_HWDBG_CTRL_PCIESEL                        0
    #define   LSb16PCIE_HWDBG_CTRL_PCIESEL                        0
    #define       bPCIE_HWDBG_CTRL_PCIESEL                     2
    #define   MSK32PCIE_HWDBG_CTRL_PCIESEL                        0x00000003

    #define     BA_PCIE_HWDBG_CTRL_DATASEL                     0xA048
    #define     B16PCIE_HWDBG_CTRL_DATASEL                     0xA048
    #define   LSb32PCIE_HWDBG_CTRL_DATASEL                        2
    #define   LSb16PCIE_HWDBG_CTRL_DATASEL                        2
    #define       bPCIE_HWDBG_CTRL_DATASEL                     1
    #define   MSK32PCIE_HWDBG_CTRL_DATASEL                        0x00000004

    #define     BA_PCIE_HWDBG_CTRL_SIGSEL                      0xA048
    #define     B16PCIE_HWDBG_CTRL_SIGSEL                      0xA048
    #define   LSb32PCIE_HWDBG_CTRL_SIGSEL                         3
    #define   LSb16PCIE_HWDBG_CTRL_SIGSEL                         3
    #define       bPCIE_HWDBG_CTRL_SIGSEL                      8
    #define   MSK32PCIE_HWDBG_CTRL_SIGSEL                         0x000007F8
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_HWDBG_DATA                             0xA04C

    #define     BA_PCIE_HWDBG_DATA_VAL                         0xA04C
    #define     B16PCIE_HWDBG_DATA_VAL                         0xA04C
    #define   LSb32PCIE_HWDBG_DATA_VAL                            0
    #define   LSb16PCIE_HWDBG_DATA_VAL                            0
    #define       bPCIE_HWDBG_DATA_VAL                         32
    #define   MSK32PCIE_HWDBG_DATA_VAL                            0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_AXI_LIMIT_LOWER                        0xA050

    #define     BA_PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER      0xA050
    #define     B16PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER      0xA050
    #define   LSb32PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER         0
    #define   LSb16PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER         0
    #define       bPCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER      32
    #define   MSK32PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER         0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_AXI_LIMIT_UPPER                        0xA054

    #define     BA_PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER      0xA054
    #define     B16PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER      0xA054
    #define   LSb32PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER         0
    #define   LSb16PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER         0
    #define       bPCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER      32
    #define   MSK32PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER         0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_SPARE_0                                0xA058

    #define     BA_PCIE_SPARE_0_REGBITS                        0xA058
    #define     B16PCIE_SPARE_0_REGBITS                        0xA058
    #define   LSb32PCIE_SPARE_0_REGBITS                           0
    #define   LSb16PCIE_SPARE_0_REGBITS                           0
    #define       bPCIE_SPARE_0_REGBITS                        32
    #define   MSK32PCIE_SPARE_0_REGBITS                           0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_SPARE_1                                0xA05C

    #define     BA_PCIE_SPARE_1_REGBITS                        0xA05C
    #define     B16PCIE_SPARE_1_REGBITS                        0xA05C
    #define   LSb32PCIE_SPARE_1_REGBITS                           0
    #define   LSb16PCIE_SPARE_1_REGBITS                           0
    #define       bPCIE_SPARE_1_REGBITS                        32
    #define   MSK32PCIE_SPARE_1_REGBITS                           0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_SPARE_2                                0xA060

    #define     BA_PCIE_SPARE_2_REGBITS                        0xA060
    #define     B16PCIE_SPARE_2_REGBITS                        0xA060
    #define   LSb32PCIE_SPARE_2_REGBITS                           0
    #define   LSb16PCIE_SPARE_2_REGBITS                           0
    #define       bPCIE_SPARE_2_REGBITS                        32
    #define   MSK32PCIE_SPARE_2_REGBITS                           0xFFFFFFFF
    ///////////////////////////////////////////////////////////
    #define     RA_PCIE_SPARE_3                                0xA064

    #define     BA_PCIE_SPARE_3_REGBITS                        0xA064
    #define     B16PCIE_SPARE_3_REGBITS                        0xA064
    #define   LSb32PCIE_SPARE_3_REGBITS                           0
    #define   LSb16PCIE_SPARE_3_REGBITS                           0
    #define       bPCIE_SPARE_3_REGBITS                        32
    #define   MSK32PCIE_SPARE_3_REGBITS                           0xFFFFFFFF
    ///////////////////////////////////////////////////////////

    typedef struct SIE_PCIE {
    ///////////////////////////////////////////////////////////
              SIE_IP_REGSP_0                                   ie_IP_REGSP_0;
    ///////////////////////////////////////////////////////////
              SIE_IP_REGSP_1                                   ie_IP_REGSP_1;
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MSI_INTR_RX_DATA(r32)                  _BFGET_(r32,31, 0)
    #define   SET32PCIE_MSI_INTR_RX_DATA(r32,v)                _BFSET_(r32,31, 0,v)

    #define     w32PCIE_MSI_INTR_RX                            {\
            UNSG32 uMSI_INTR_RX_DATA                           : 32;\
          }
    union { UNSG32 u32PCIE_MSI_INTR_RX;
            struct w32PCIE_MSI_INTR_RX;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MSI_INTR_STATUS_VALUE(r32)             _BFGET_(r32,31, 0)
    #define   SET32PCIE_MSI_INTR_STATUS_VALUE(r32,v)           _BFSET_(r32,31, 0,v)

    #define     w32PCIE_MSI_INTR_STATUS                        {\
            UNSG32 uMSI_INTR_STATUS_VALUE                      : 32;\
          }
    union { UNSG32 u32PCIE_MSI_INTR_STATUS;
            struct w32PCIE_MSI_INTR_STATUS;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MSI_INTR_MASK_VALUE(r32)               _BFGET_(r32,31, 0)
    #define   SET32PCIE_MSI_INTR_MASK_VALUE(r32,v)             _BFSET_(r32,31, 0,v)

    #define     w32PCIE_MSI_INTR_MASK                          {\
            UNSG32 uMSI_INTR_MASK_VALUE                        : 32;\
          }
    union { UNSG32 u32PCIE_MSI_INTR_MASK;
            struct w32PCIE_MSI_INTR_MASK;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR(r32)      _BFGET_(r32, 0, 0)
    #define   SET32PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR(r32,v)    _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR(r16)      _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_INTR_STATUS_AXI_ADDR_OOR(r16,v)    _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_INTR_STATUS_MSI_CTRL_INT(r32)      _BFGET_(r32, 1, 1)
    #define   SET32PCIE_MAC_INTR_STATUS_MSI_CTRL_INT(r32,v)    _BFSET_(r32, 1, 1,v)
    #define   GET16PCIE_MAC_INTR_STATUS_MSI_CTRL_INT(r16)      _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_INTR_STATUS_MSI_CTRL_INT(r16,v)    _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_INTR_STATUS_HP_INT(r32)            _BFGET_(r32, 2, 2)
    #define   SET32PCIE_MAC_INTR_STATUS_HP_INT(r32,v)          _BFSET_(r32, 2, 2,v)
    #define   GET16PCIE_MAC_INTR_STATUS_HP_INT(r16)            _BFGET_(r16, 2, 2)
    #define   SET16PCIE_MAC_INTR_STATUS_HP_INT(r16,v)          _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_PME_INT(r32)       _BFGET_(r32, 3, 3)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_PME_INT(r32,v)     _BFSET_(r32, 3, 3,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_PME_INT(r16)       _BFGET_(r16, 3, 3)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_PME_INT(r16,v)     _BFSET_(r16, 3, 3,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT(r32) _BFGET_(r32, 4, 4)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT(r32,v) _BFSET_(r32, 4, 4,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT(r16) _BFGET_(r16, 4, 4)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_INT(r16,v) _BFSET_(r16, 4, 4,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI(r32) _BFGET_(r32, 5, 5)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI(r32,v) _BFSET_(r32, 5, 5,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI(r16) _BFGET_(r16, 5, 5)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_AER_RC_ERR_MSI(r16,v) _BFSET_(r16, 5, 5,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC(r32)    _BFGET_(r32, 6, 6)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC(r32,v)  _BFSET_(r32, 6, 6,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC(r16)    _BFGET_(r16, 6, 6)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_SYS_ERR_RC(r16,v)  _BFSET_(r16, 6, 6,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_PME_MSI(r32)       _BFGET_(r32, 7, 7)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_PME_MSI(r32,v)     _BFSET_(r32, 7, 7,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_PME_MSI(r16)       _BFGET_(r16, 7, 7)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_PME_MSI(r16,v)     _BFSET_(r16, 7, 7,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR(r32) _BFGET_(r32, 8, 8)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR(r32,v) _BFSET_(r32, 8, 8,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR(r16) _BFGET_(r16, 8, 8)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_CORRECTABLE_ERR(r16,v) _BFSET_(r16, 8, 8,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR(r32) _BFGET_(r32, 9, 9)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR(r32,v) _BFSET_(r32, 9, 9,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR(r16) _BFGET_(r16, 9, 9)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_NONFATAL_ERR(r16,v) _BFSET_(r16, 9, 9,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR(r32)    _BFGET_(r32,10,10)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR(r32,v)  _BFSET_(r32,10,10,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR(r16)    _BFGET_(r16,10,10)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_FATAL_ERR(r16,v)  _BFSET_(r16,10,10,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_PM_PME(r32)       _BFGET_(r32,11,11)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_PM_PME(r32,v)     _BFSET_(r32,11,11,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_PM_PME(r16)       _BFGET_(r16,11,11)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_PM_PME(r16,v)     _BFSET_(r16,11,11,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK(r32)    _BFGET_(r32,12,12)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK(r32,v)  _BFSET_(r32,12,12,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK(r16)    _BFGET_(r16,12,12)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_PM_TO_ACK(r16,v)  _BFSET_(r16,12,12,v)

    #define   GET32PCIE_MAC_INTR_STATUS_HP_PME(r32)            _BFGET_(r32,13,13)
    #define   SET32PCIE_MAC_INTR_STATUS_HP_PME(r32,v)          _BFSET_(r32,13,13,v)
    #define   GET16PCIE_MAC_INTR_STATUS_HP_PME(r16)            _BFGET_(r16,13,13)
    #define   SET16PCIE_MAC_INTR_STATUS_HP_PME(r16,v)          _BFSET_(r16,13,13,v)

    #define   GET32PCIE_MAC_INTR_STATUS_HP_MSI(r32)            _BFGET_(r32,14,14)
    #define   SET32PCIE_MAC_INTR_STATUS_HP_MSI(r32,v)          _BFSET_(r32,14,14,v)
    #define   GET16PCIE_MAC_INTR_STATUS_HP_MSI(r16)            _BFGET_(r16,14,14)
    #define   SET16PCIE_MAC_INTR_STATUS_HP_MSI(r16,v)          _BFSET_(r16,14,14,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT(r32) _BFGET_(r32,15,15)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT(r32,v) _BFSET_(r32,15,15,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT(r16) _BFGET_(r16,15,15)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT(r16,v) _BFSET_(r16,15,15,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI(r32) _BFGET_(r32,16,16)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI(r32,v) _BFSET_(r32,16,16,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI(r16) _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI(r16,v) _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT(r32)    _BFGET_(r32,17,17)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT(r32,v)  _BFSET_(r32,17,17,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT(r16)    _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_INT(r16,v)  _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI(r32)    _BFGET_(r32,18,18)
    #define   SET32PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI(r32,v)  _BFSET_(r32,18,18,v)
    #define   GET16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI(r16)    _BFGET_(r16, 2, 2)
    #define   SET16PCIE_MAC_INTR_STATUS_CFG_BW_MGT_MSI(r16,v)  _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED(r32) _BFGET_(r32,19,19)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED(r32,v) _BFSET_(r32,19,19,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED(r16) _BFGET_(r16, 3, 3)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTA_ASSERTED(r16,v) _BFSET_(r16, 3, 3,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED(r32) _BFGET_(r32,20,20)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED(r32,v) _BFSET_(r32,20,20,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED(r16) _BFGET_(r16, 4, 4)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTB_ASSERTED(r16,v) _BFSET_(r16, 4, 4,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED(r32) _BFGET_(r32,21,21)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED(r32,v) _BFSET_(r32,21,21,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED(r16) _BFGET_(r16, 5, 5)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTC_ASSERTED(r16,v) _BFSET_(r16, 5, 5,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED(r32) _BFGET_(r32,22,22)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED(r32,v) _BFSET_(r32,22,22,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED(r16) _BFGET_(r16, 6, 6)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTD_ASSERTED(r16,v) _BFSET_(r16, 6, 6,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED(r32) _BFGET_(r32,23,23)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED(r32,v) _BFSET_(r32,23,23,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED(r16) _BFGET_(r16, 7, 7)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTA_DEASSERTED(r16,v) _BFSET_(r16, 7, 7,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED(r32) _BFGET_(r32,24,24)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED(r32,v) _BFSET_(r32,24,24,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED(r16) _BFGET_(r16, 8, 8)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTB_DEASSERTED(r16,v) _BFSET_(r16, 8, 8,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED(r32) _BFGET_(r32,25,25)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED(r32,v) _BFSET_(r32,25,25,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED(r16) _BFGET_(r16, 9, 9)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTC_DEASSERTED(r16,v) _BFSET_(r16, 9, 9,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED(r32) _BFGET_(r32,26,26)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED(r32,v) _BFSET_(r32,26,26,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED(r16) _BFGET_(r16,10,10)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_INTD_DEASSERTED(r16,v) _BFSET_(r16,10,10,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW(r32)    _BFGET_(r32,27,27)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW(r32,v)  _BFSET_(r32,27,27,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW(r16)    _BFGET_(r16,11,11)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_QOVERFLOW(r16,v)  _BFSET_(r16,11,11,v)

    #define   GET32PCIE_MAC_INTR_STATUS_SMLH_LINK_UP(r32)      _BFGET_(r32,28,28)
    #define   SET32PCIE_MAC_INTR_STATUS_SMLH_LINK_UP(r32,v)    _BFSET_(r32,28,28,v)
    #define   GET16PCIE_MAC_INTR_STATUS_SMLH_LINK_UP(r16)      _BFGET_(r16,12,12)
    #define   SET16PCIE_MAC_INTR_STATUS_SMLH_LINK_UP(r16,v)    _BFSET_(r16,12,12,v)

    #define   GET32PCIE_MAC_INTR_STATUS_SMLH_LINK_DN(r32)      _BFGET_(r32,29,29)
    #define   SET32PCIE_MAC_INTR_STATUS_SMLH_LINK_DN(r32,v)    _BFSET_(r32,29,29,v)
    #define   GET16PCIE_MAC_INTR_STATUS_SMLH_LINK_DN(r16)      _BFGET_(r16,13,13)
    #define   SET16PCIE_MAC_INTR_STATUS_SMLH_LINK_DN(r16,v)    _BFSET_(r16,13,13,v)

    #define   GET32PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT(r32)  _BFGET_(r32,30,30)
    #define   SET32PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT(r32,v) _BFSET_(r32,30,30,v)
    #define   GET16PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT(r16)  _BFGET_(r16,14,14)
    #define   SET16PCIE_MAC_INTR_STATUS_RADM_CPL_TIMEOUT(r16,v) _BFSET_(r16,14,14,v)

    #define     w32PCIE_MAC_INTR_STATUS                        {\
            UNSG32 uMAC_INTR_STATUS_AXI_ADDR_OOR               :  1;\
            UNSG32 uMAC_INTR_STATUS_MSI_CTRL_INT               :  1;\
            UNSG32 uMAC_INTR_STATUS_HP_INT                     :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_PME_INT                :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_AER_RC_ERR_INT         :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_AER_RC_ERR_MSI         :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_SYS_ERR_RC             :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_PME_MSI                :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_CORRECTABLE_ERR       :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_NONFATAL_ERR          :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_FATAL_ERR             :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_PM_PME                :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_PM_TO_ACK             :  1;\
            UNSG32 uMAC_INTR_STATUS_HP_PME                     :  1;\
            UNSG32 uMAC_INTR_STATUS_HP_MSI                     :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_LINK_AUTO_BW_INT       :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_LINK_AUTO_BW_MSI       :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_BW_MGT_INT             :  1;\
            UNSG32 uMAC_INTR_STATUS_CFG_BW_MGT_MSI             :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTA_ASSERTED         :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTB_ASSERTED         :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTC_ASSERTED         :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTD_ASSERTED         :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTA_DEASSERTED       :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTB_DEASSERTED       :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTC_DEASSERTED       :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_INTD_DEASSERTED       :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_QOVERFLOW             :  1;\
            UNSG32 uMAC_INTR_STATUS_SMLH_LINK_UP               :  1;\
            UNSG32 uMAC_INTR_STATUS_SMLH_LINK_DN               :  1;\
            UNSG32 uMAC_INTR_STATUS_RADM_CPL_TIMEOUT           :  1;\
            UNSG32 RSVDxA00C_b31                               :  1;\
          }
    union { UNSG32 u32PCIE_MAC_INTR_STATUS;
            struct w32PCIE_MAC_INTR_STATUS;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_INTR_MASK_INTR_MASK(r32)           _BFGET_(r32,31, 0)
    #define   SET32PCIE_MAC_INTR_MASK_INTR_MASK(r32,v)         _BFSET_(r32,31, 0,v)

    #define     w32PCIE_MAC_INTR_MASK                          {\
            UNSG32 uMAC_INTR_MASK_INTR_MASK                    : 32;\
          }
    union { UNSG32 u32PCIE_MAC_INTR_MASK;
            struct w32PCIE_MAC_INTR_MASK;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH(r32) _BFGET_(r32, 0, 0)
    #define   SET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH(r32,v) _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH(r16) _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH(r16,v) _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR(r32) _BFGET_(r32, 1, 1)
    #define   SET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR(r32,v) _BFSET_(r32, 1, 1,v)
    #define   GET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR(r16) _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR(r16,v) _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH(r32) _BFGET_(r32, 2, 2)
    #define   SET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH(r32,v) _BFSET_(r32, 2, 2,v)
    #define   GET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH(r16) _BFGET_(r16, 2, 2)
    #define   SET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH(r16,v) _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR(r32) _BFGET_(r32, 3, 3)
    #define   SET32PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR(r32,v) _BFSET_(r32, 3, 3,v)
    #define   GET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR(r16) _BFGET_(r16, 3, 3)
    #define   SET16PCIE_MAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR(r16,v) _BFSET_(r16, 3, 3,v)

    #define     w32PCIE_MAC_INTR_STATUS1                       {\
            UNSG32 uMAC_INTR_STATUS1_RADM_TRGT1_ATU0_SLOC_MATCH :  1;\
            UNSG32 uMAC_INTR_STATUS1_RADM_TRGT1_ATU0_CBUF_ERR  :  1;\
            UNSG32 uMAC_INTR_STATUS1_RADM_TRGT1_ATU1_SLOC_MATCH :  1;\
            UNSG32 uMAC_INTR_STATUS1_RADM_TRGT1_ATU1_CBUF_ERR  :  1;\
            UNSG32 RSVDxA014_b4                                : 28;\
          }
    union { UNSG32 u32PCIE_MAC_INTR_STATUS1;
            struct w32PCIE_MAC_INTR_STATUS1;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_INTR_MASK1_INTR_MASK1(r32)         _BFGET_(r32,31, 0)
    #define   SET32PCIE_MAC_INTR_MASK1_INTR_MASK1(r32,v)       _BFSET_(r32,31, 0,v)

    #define     w32PCIE_MAC_INTR_MASK1                         {\
            UNSG32 uMAC_INTR_MASK1_INTR_MASK1                  : 32;\
          }
    union { UNSG32 u32PCIE_MAC_INTR_MASK1;
            struct w32PCIE_MAC_INTR_MASK1;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_CTRL_SYSWREQ(r32)                  _BFGET_(r32, 0, 0)
    #define   SET32PCIE_MAC_CTRL_SYSWREQ(r32,v)                _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_MAC_CTRL_SYSWREQ(r16)                  _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_CTRL_SYSWREQ(r16,v)                _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_CTRL_CPU_INTERFACE_SEL(r32)        _BFGET_(r32, 1, 1)
    #define   SET32PCIE_MAC_CTRL_CPU_INTERFACE_SEL(r32,v)      _BFSET_(r32, 1, 1,v)
    #define   GET16PCIE_MAC_CTRL_CPU_INTERFACE_SEL(r16)        _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_CTRL_CPU_INTERFACE_SEL(r16,v)      _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_CTRL_CFG_TYPE(r32)                 _BFGET_(r32, 2, 2)
    #define   SET32PCIE_MAC_CTRL_CFG_TYPE(r32,v)               _BFSET_(r32, 2, 2,v)
    #define   GET16PCIE_MAC_CTRL_CFG_TYPE(r16)                 _BFGET_(r16, 2, 2)
    #define   SET16PCIE_MAC_CTRL_CFG_TYPE(r16,v)               _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_MAC_CTRL_MEMMAP_CFG_VALID(r32)         _BFGET_(r32, 3, 3)
    #define   SET32PCIE_MAC_CTRL_MEMMAP_CFG_VALID(r32,v)       _BFSET_(r32, 3, 3,v)
    #define   GET16PCIE_MAC_CTRL_MEMMAP_CFG_VALID(r16)         _BFGET_(r16, 3, 3)
    #define   SET16PCIE_MAC_CTRL_MEMMAP_CFG_VALID(r16,v)       _BFSET_(r16, 3, 3,v)

    #define   GET32PCIE_MAC_CTRL_SYS_AUX_PWR_DET(r32)          _BFGET_(r32, 4, 4)
    #define   SET32PCIE_MAC_CTRL_SYS_AUX_PWR_DET(r32,v)        _BFSET_(r32, 4, 4,v)
    #define   GET16PCIE_MAC_CTRL_SYS_AUX_PWR_DET(r16)          _BFGET_(r16, 4, 4)
    #define   SET16PCIE_MAC_CTRL_SYS_AUX_PWR_DET(r16,v)        _BFSET_(r16, 4, 4,v)

    #define   GET32PCIE_MAC_CTRL_APP_LTSSM_ENABLE(r32)         _BFGET_(r32, 5, 5)
    #define   SET32PCIE_MAC_CTRL_APP_LTSSM_ENABLE(r32,v)       _BFSET_(r32, 5, 5,v)
    #define   GET16PCIE_MAC_CTRL_APP_LTSSM_ENABLE(r16)         _BFGET_(r16, 5, 5)
    #define   SET16PCIE_MAC_CTRL_APP_LTSSM_ENABLE(r16,v)       _BFSET_(r16, 5, 5,v)

    #define   GET32PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN(r32) _BFGET_(r32, 6, 6)
    #define   SET32PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN(r32,v) _BFSET_(r32, 6, 6,v)
    #define   GET16PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN(r16) _BFGET_(r16, 6, 6)
    #define   SET16PCIE_MAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN(r16,v) _BFSET_(r16, 6, 6,v)

    #define   GET32PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN(r32) _BFGET_(r32, 7, 7)
    #define   SET32PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN(r32,v) _BFSET_(r32, 7, 7,v)
    #define   GET16PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN(r16) _BFGET_(r16, 7, 7)
    #define   SET16PCIE_MAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN(r16,v) _BFSET_(r16, 7, 7,v)

    #define   GET32PCIE_MAC_CTRL_ADDR_FILTER_FLAG(r32)         _BFGET_(r32, 8, 8)
    #define   SET32PCIE_MAC_CTRL_ADDR_FILTER_FLAG(r32,v)       _BFSET_(r32, 8, 8,v)
    #define   GET16PCIE_MAC_CTRL_ADDR_FILTER_FLAG(r16)         _BFGET_(r16, 8, 8)
    #define   SET16PCIE_MAC_CTRL_ADDR_FILTER_FLAG(r16,v)       _BFSET_(r16, 8, 8,v)

    #define   GET32PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N(r32)     _BFGET_(r32, 9, 9)
    #define   SET32PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N(r32,v)   _BFSET_(r32, 9, 9,v)
    #define   GET16PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N(r16)     _BFGET_(r16, 9, 9)
    #define   SET16PCIE_MAC_CTRL_PCIEM_DS_RESP_MASK_N(r16,v)   _BFSET_(r16, 9, 9,v)

    #define   GET32PCIE_MAC_CTRL_CLK_RST_BYPASS(r32)           _BFGET_(r32,10,10)
    #define   SET32PCIE_MAC_CTRL_CLK_RST_BYPASS(r32,v)         _BFSET_(r32,10,10,v)
    #define   GET16PCIE_MAC_CTRL_CLK_RST_BYPASS(r16)           _BFGET_(r16,10,10)
    #define   SET16PCIE_MAC_CTRL_CLK_RST_BYPASS(r16,v)         _BFSET_(r16,10,10,v)

    #define   GET32PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE(r32)       _BFGET_(r32,11,11)
    #define   SET32PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE(r32,v)     _BFSET_(r32,11,11,v)
    #define   GET16PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE(r16)       _BFGET_(r16,11,11)
    #define   SET16PCIE_MAC_CTRL_MAC_DBI_CS2_ENABLE(r16,v)     _BFSET_(r16,11,11,v)

    #define   GET32PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL(r32)    _BFGET_(r32,12,12)
    #define   SET32PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL(r32,v)  _BFSET_(r32,12,12,v)
    #define   GET16PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL(r16)    _BFGET_(r16,12,12)
    #define   SET16PCIE_MAC_CTRL_MAC_DBI_iATU_ADDR_SEL(r16,v)  _BFSET_(r16,12,12,v)

    #define   GET32PCIE_MAC_CTRL_APP_CLK_REQ_N(r32)            _BFGET_(r32,13,13)
    #define   SET32PCIE_MAC_CTRL_APP_CLK_REQ_N(r32,v)          _BFSET_(r32,13,13,v)
    #define   GET16PCIE_MAC_CTRL_APP_CLK_REQ_N(r16)            _BFGET_(r16,13,13)
    #define   SET16PCIE_MAC_CTRL_APP_CLK_REQ_N(r16,v)          _BFSET_(r16,13,13,v)

    #define   GET32PCIE_MAC_CTRL_APP_REQ_EXIT_L1(r32)          _BFGET_(r32,14,14)
    #define   SET32PCIE_MAC_CTRL_APP_REQ_EXIT_L1(r32,v)        _BFSET_(r32,14,14,v)
    #define   GET16PCIE_MAC_CTRL_APP_REQ_EXIT_L1(r16)          _BFGET_(r16,14,14)
    #define   SET16PCIE_MAC_CTRL_APP_REQ_EXIT_L1(r16,v)        _BFSET_(r16,14,14,v)

    #define   GET32PCIE_MAC_CTRL_APP_XFER_PENDING(r32)         _BFGET_(r32,15,15)
    #define   SET32PCIE_MAC_CTRL_APP_XFER_PENDING(r32,v)       _BFSET_(r32,15,15,v)
    #define   GET16PCIE_MAC_CTRL_APP_XFER_PENDING(r16)         _BFGET_(r16,15,15)
    #define   SET16PCIE_MAC_CTRL_APP_XFER_PENDING(r16,v)       _BFSET_(r16,15,15,v)

    #define   GET32PCIE_MAC_CTRL_APP_CLK_PM_EN(r32)            _BFGET_(r32,16,16)
    #define   SET32PCIE_MAC_CTRL_APP_CLK_PM_EN(r32,v)          _BFSET_(r32,16,16,v)
    #define   GET16PCIE_MAC_CTRL_APP_CLK_PM_EN(r16)            _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_CTRL_APP_CLK_PM_EN(r16,v)          _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_CTRL_PIPE2PIPE_BYPASS(r32)         _BFGET_(r32,17,17)
    #define   SET32PCIE_MAC_CTRL_PIPE2PIPE_BYPASS(r32,v)       _BFSET_(r32,17,17,v)
    #define   GET16PCIE_MAC_CTRL_PIPE2PIPE_BYPASS(r16)         _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_CTRL_PIPE2PIPE_BYPASS(r16,v)       _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF(r32)      _BFGET_(r32,18,18)
    #define   SET32PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF(r32,v)    _BFSET_(r32,18,18,v)
    #define   GET16PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF(r16)      _BFGET_(r16, 2, 2)
    #define   SET16PCIE_MAC_CTRL_APPS_PM_XMT_TURNOFF(r16,v)    _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_MAC_CTRL_CLEAR_L2_INTR(r32)            _BFGET_(r32,19,19)
    #define   SET32PCIE_MAC_CTRL_CLEAR_L2_INTR(r32,v)          _BFSET_(r32,19,19,v)
    #define   GET16PCIE_MAC_CTRL_CLEAR_L2_INTR(r16)            _BFGET_(r16, 3, 3)
    #define   SET16PCIE_MAC_CTRL_CLEAR_L2_INTR(r16,v)          _BFSET_(r16, 3, 3,v)

    #define   GET32PCIE_MAC_CTRL_SLV_WMISC_INFO(r32)           _BFGET_(r32,20,20)
    #define   SET32PCIE_MAC_CTRL_SLV_WMISC_INFO(r32,v)         _BFSET_(r32,20,20,v)
    #define   GET16PCIE_MAC_CTRL_SLV_WMISC_INFO(r16)           _BFGET_(r16, 4, 4)
    #define   SET16PCIE_MAC_CTRL_SLV_WMISC_INFO(r16,v)         _BFSET_(r16, 4, 4,v)

    #define   GET32PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS(r32)        _BFGET_(r32,21,21)
    #define   SET32PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS(r32,v)      _BFSET_(r32,21,21,v)
    #define   GET16PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS(r16)        _BFGET_(r16, 5, 5)
    #define   SET16PCIE_MAC_CTRL_APP_DBI_RO_WR_DIS(r16,v)      _BFSET_(r16, 5, 5,v)

    #define   GET32PCIE_MAC_CTRL_RX_LANE_FLIP_EN(r32)          _BFGET_(r32,22,22)
    #define   SET32PCIE_MAC_CTRL_RX_LANE_FLIP_EN(r32,v)        _BFSET_(r32,22,22,v)
    #define   GET16PCIE_MAC_CTRL_RX_LANE_FLIP_EN(r16)          _BFGET_(r16, 6, 6)
    #define   SET16PCIE_MAC_CTRL_RX_LANE_FLIP_EN(r16,v)        _BFSET_(r16, 6, 6,v)

    #define   GET32PCIE_MAC_CTRL_TX_LANE_FLIP_EN(r32)          _BFGET_(r32,23,23)
    #define   SET32PCIE_MAC_CTRL_TX_LANE_FLIP_EN(r32,v)        _BFSET_(r32,23,23,v)
    #define   GET16PCIE_MAC_CTRL_TX_LANE_FLIP_EN(r16)          _BFGET_(r16, 7, 7)
    #define   SET16PCIE_MAC_CTRL_TX_LANE_FLIP_EN(r16,v)        _BFSET_(r16, 7, 7,v)

    #define   GET32PCIE_MAC_CTRL_APP_HOLD_PHY_RST(r32)         _BFGET_(r32,24,24)
    #define   SET32PCIE_MAC_CTRL_APP_HOLD_PHY_RST(r32,v)       _BFSET_(r32,24,24,v)
    #define   GET16PCIE_MAC_CTRL_APP_HOLD_PHY_RST(r16)         _BFGET_(r16, 8, 8)
    #define   SET16PCIE_MAC_CTRL_APP_HOLD_PHY_RST(r16,v)       _BFSET_(r16, 8, 8,v)

    #define     w32PCIE_MAC_CTRL                               {\
            UNSG32 uMAC_CTRL_SYSWREQ                           :  1;\
            UNSG32 uMAC_CTRL_CPU_INTERFACE_SEL                 :  1;\
            UNSG32 uMAC_CTRL_CFG_TYPE                          :  1;\
            UNSG32 uMAC_CTRL_MEMMAP_CFG_VALID                  :  1;\
            UNSG32 uMAC_CTRL_SYS_AUX_PWR_DET                   :  1;\
            UNSG32 uMAC_CTRL_APP_LTSSM_ENABLE                  :  1;\
            UNSG32 uMAC_CTRL_CFG_L1_AUX_CLK_SWITCH_CORE_CLK_GATE_EN :  1;\
            UNSG32 uMAC_CTRL_CFG_L1_MAC_POWERDOWN_OVERRIDE_TO_P2_EN :  1;\
            UNSG32 uMAC_CTRL_ADDR_FILTER_FLAG                  :  1;\
            UNSG32 uMAC_CTRL_PCIEM_DS_RESP_MASK_N              :  1;\
            UNSG32 uMAC_CTRL_CLK_RST_BYPASS                    :  1;\
            UNSG32 uMAC_CTRL_MAC_DBI_CS2_ENABLE                :  1;\
            UNSG32 uMAC_CTRL_MAC_DBI_iATU_ADDR_SEL             :  1;\
            UNSG32 uMAC_CTRL_APP_CLK_REQ_N                     :  1;\
            UNSG32 uMAC_CTRL_APP_REQ_EXIT_L1                   :  1;\
            UNSG32 uMAC_CTRL_APP_XFER_PENDING                  :  1;\
            UNSG32 uMAC_CTRL_APP_CLK_PM_EN                     :  1;\
            UNSG32 uMAC_CTRL_PIPE2PIPE_BYPASS                  :  1;\
            UNSG32 uMAC_CTRL_APPS_PM_XMT_TURNOFF               :  1;\
            UNSG32 uMAC_CTRL_CLEAR_L2_INTR                     :  1;\
            UNSG32 uMAC_CTRL_SLV_WMISC_INFO                    :  1;\
            UNSG32 uMAC_CTRL_APP_DBI_RO_WR_DIS                 :  1;\
            UNSG32 uMAC_CTRL_RX_LANE_FLIP_EN                   :  1;\
            UNSG32 uMAC_CTRL_TX_LANE_FLIP_EN                   :  1;\
            UNSG32 uMAC_CTRL_APP_HOLD_PHY_RST                  :  1;\
            UNSG32 RSVDxA01C_b25                               :  7;\
          }
    union { UNSG32 u32PCIE_MAC_CTRL;
            struct w32PCIE_MAC_CTRL;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_STATUS_DWACK(r32)                  _BFGET_(r32, 0, 0)
    #define   SET32PCIE_MAC_STATUS_DWACK(r32,v)                _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_MAC_STATUS_DWACK(r16)                  _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_STATUS_DWACK(r16,v)                _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_STATUS_RDLH_LINK_UP(r32)           _BFGET_(r32, 1, 1)
    #define   SET32PCIE_MAC_STATUS_RDLH_LINK_UP(r32,v)         _BFSET_(r32, 1, 1,v)
    #define   GET16PCIE_MAC_STATUS_RDLH_LINK_UP(r16)           _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_STATUS_RDLH_LINK_UP(r16,v)         _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_STATUS_PM_CURNT_STATE(r32)         _BFGET_(r32, 4, 2)
    #define   SET32PCIE_MAC_STATUS_PM_CURNT_STATE(r32,v)       _BFSET_(r32, 4, 2,v)
    #define   GET16PCIE_MAC_STATUS_PM_CURNT_STATE(r16)         _BFGET_(r16, 4, 2)
    #define   SET16PCIE_MAC_STATUS_PM_CURNT_STATE(r16,v)       _BFSET_(r16, 4, 2,v)

    #define   GET32PCIE_MAC_STATUS_SMLH_LTSSM_STATE(r32)       _BFGET_(r32,10, 5)
    #define   SET32PCIE_MAC_STATUS_SMLH_LTSSM_STATE(r32,v)     _BFSET_(r32,10, 5,v)
    #define   GET16PCIE_MAC_STATUS_SMLH_LTSSM_STATE(r16)       _BFGET_(r16,10, 5)
    #define   SET16PCIE_MAC_STATUS_SMLH_LTSSM_STATE(r16,v)     _BFSET_(r16,10, 5,v)

    #define   GET32PCIE_MAC_STATUS_SMLH_LINK_UP(r32)           _BFGET_(r32,11,11)
    #define   SET32PCIE_MAC_STATUS_SMLH_LINK_UP(r32,v)         _BFSET_(r32,11,11,v)
    #define   GET16PCIE_MAC_STATUS_SMLH_LINK_UP(r16)           _BFGET_(r16,11,11)
    #define   SET16PCIE_MAC_STATUS_SMLH_LINK_UP(r16,v)         _BFSET_(r16,11,11,v)

    #define   GET32PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY(r32)       _BFGET_(r32,12,12)
    #define   SET32PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY(r32,v)     _BFSET_(r32,12,12,v)
    #define   GET16PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY(r16)       _BFGET_(r16,12,12)
    #define   SET16PCIE_MAC_STATUS_RADM_Q_NOT_EMPTY(r16,v)     _BFSET_(r16,12,12,v)

    #define   GET32PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT(r32)       _BFGET_(r32,13,13)
    #define   SET32PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT(r32,v)     _BFSET_(r32,13,13,v)
    #define   GET16PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT(r16)       _BFGET_(r16,13,13)
    #define   SET16PCIE_MAC_STATUS_TRGT_CPL_TIMEOUT(r16,v)     _BFSET_(r16,13,13,v)

    #define   GET32PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP(r32)      _BFGET_(r32,14,14)
    #define   SET32PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP(r32,v)    _BFSET_(r32,14,14,v)
    #define   GET16PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP(r16)      _BFGET_(r16,14,14)
    #define   SET16PCIE_MAC_STATUS_PM_XTLH_BLOCK_TLP(r16,v)    _BFSET_(r16,14,14,v)

    #define   GET32PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING(r32)  _BFGET_(r32,15,15)
    #define   SET32PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING(r32,v) _BFSET_(r32,15,15,v)
    #define   GET16PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING(r16)  _BFGET_(r16,15,15)
    #define   SET16PCIE_MAC_STATUS_BRDG_SLV_XFER_PENDING(r16,v) _BFSET_(r16,15,15,v)

    #define   GET32PCIE_MAC_STATUS_RADM_CPL_TIMEOUT(r32)       _BFGET_(r32,16,16)
    #define   SET32PCIE_MAC_STATUS_RADM_CPL_TIMEOUT(r32,v)     _BFSET_(r32,16,16,v)
    #define   GET16PCIE_MAC_STATUS_RADM_CPL_TIMEOUT(r16)       _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_STATUS_RADM_CPL_TIMEOUT(r16,v)     _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_STATUS_CFG_INT_PIN(r32)            _BFGET_(r32,24,17)
    #define   SET32PCIE_MAC_STATUS_CFG_INT_PIN(r32,v)          _BFSET_(r32,24,17,v)
    #define   GET16PCIE_MAC_STATUS_CFG_INT_PIN(r16)            _BFGET_(r16, 8, 1)
    #define   SET16PCIE_MAC_STATUS_CFG_INT_PIN(r16,v)          _BFSET_(r16, 8, 1,v)

    #define     w32PCIE_MAC_STATUS                             {\
            UNSG32 uMAC_STATUS_DWACK                           :  1;\
            UNSG32 uMAC_STATUS_RDLH_LINK_UP                    :  1;\
            UNSG32 uMAC_STATUS_PM_CURNT_STATE                  :  3;\
            UNSG32 uMAC_STATUS_SMLH_LTSSM_STATE                :  6;\
            UNSG32 uMAC_STATUS_SMLH_LINK_UP                    :  1;\
            UNSG32 uMAC_STATUS_RADM_Q_NOT_EMPTY                :  1;\
            UNSG32 uMAC_STATUS_TRGT_CPL_TIMEOUT                :  1;\
            UNSG32 uMAC_STATUS_PM_XTLH_BLOCK_TLP               :  1;\
            UNSG32 uMAC_STATUS_BRDG_SLV_XFER_PENDING           :  1;\
            UNSG32 uMAC_STATUS_RADM_CPL_TIMEOUT                :  1;\
            UNSG32 uMAC_STATUS_CFG_INT_PIN                     :  8;\
            UNSG32 RSVDxA020_b25                               :  7;\
          }
    union { UNSG32 u32PCIE_MAC_STATUS;
            struct w32PCIE_MAC_STATUS;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_RID_REG_BUS_NUM(r32)               _BFGET_(r32, 7, 0)
    #define   SET32PCIE_MAC_RID_REG_BUS_NUM(r32,v)             _BFSET_(r32, 7, 0,v)
    #define   GET16PCIE_MAC_RID_REG_BUS_NUM(r16)               _BFGET_(r16, 7, 0)
    #define   SET16PCIE_MAC_RID_REG_BUS_NUM(r16,v)             _BFSET_(r16, 7, 0,v)

    #define   GET32PCIE_MAC_RID_REG_DEV_NUM(r32)               _BFGET_(r32,12, 8)
    #define   SET32PCIE_MAC_RID_REG_DEV_NUM(r32,v)             _BFSET_(r32,12, 8,v)
    #define   GET16PCIE_MAC_RID_REG_DEV_NUM(r16)               _BFGET_(r16,12, 8)
    #define   SET16PCIE_MAC_RID_REG_DEV_NUM(r16,v)             _BFSET_(r16,12, 8,v)

    #define     w32PCIE_MAC_RID_REG                            {\
            UNSG32 uMAC_RID_REG_BUS_NUM                        :  8;\
            UNSG32 uMAC_RID_REG_DEV_NUM                        :  5;\
            UNSG32 RSVDxA024_b13                               : 19;\
          }
    union { UNSG32 u32PCIE_MAC_RID_REG;
            struct w32PCIE_MAC_RID_REG;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_MAC_CLK_CTRL_AXI_CLKEN(r32)            _BFGET_(r32, 0, 0)
    #define   SET32PCIE_MAC_CLK_CTRL_AXI_CLKEN(r32,v)          _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_MAC_CLK_CTRL_AXI_CLKEN(r16)            _BFGET_(r16, 0, 0)
    #define   SET16PCIE_MAC_CLK_CTRL_AXI_CLKEN(r16,v)          _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_MAC_CLK_CTRL_AHB_CLKEN(r32)            _BFGET_(r32, 1, 1)
    #define   SET32PCIE_MAC_CLK_CTRL_AHB_CLKEN(r32,v)          _BFSET_(r32, 1, 1,v)
    #define   GET16PCIE_MAC_CLK_CTRL_AHB_CLKEN(r16)            _BFGET_(r16, 1, 1)
    #define   SET16PCIE_MAC_CLK_CTRL_AHB_CLKEN(r16,v)          _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_MAC_CLK_CTRL_CORE_CLKEN(r32)           _BFGET_(r32, 2, 2)
    #define   SET32PCIE_MAC_CLK_CTRL_CORE_CLKEN(r32,v)         _BFSET_(r32, 2, 2,v)
    #define   GET16PCIE_MAC_CLK_CTRL_CORE_CLKEN(r16)           _BFGET_(r16, 2, 2)
    #define   SET16PCIE_MAC_CLK_CTRL_CORE_CLKEN(r16,v)         _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_MAC_CLK_CTRL_PIPE_CLKEN(r32)           _BFGET_(r32, 3, 3)
    #define   SET32PCIE_MAC_CLK_CTRL_PIPE_CLKEN(r32,v)         _BFSET_(r32, 3, 3,v)
    #define   GET16PCIE_MAC_CLK_CTRL_PIPE_CLKEN(r16)           _BFGET_(r16, 3, 3)
    #define   SET16PCIE_MAC_CLK_CTRL_PIPE_CLKEN(r16,v)         _BFSET_(r16, 3, 3,v)

    #define     w32PCIE_MAC_CLK_CTRL                           {\
            UNSG32 uMAC_CLK_CTRL_AXI_CLKEN                     :  1;\
            UNSG32 uMAC_CLK_CTRL_AHB_CLKEN                     :  1;\
            UNSG32 uMAC_CLK_CTRL_CORE_CLKEN                    :  1;\
            UNSG32 uMAC_CLK_CTRL_PIPE_CLKEN                    :  1;\
            UNSG32 RSVDxA028_b4                                : 28;\
          }
    union { UNSG32 u32PCIE_MAC_CLK_CTRL;
            struct w32PCIE_MAC_CLK_CTRL;
          };
    ///////////////////////////////////////////////////////////
              SIE_REFCLK                                       ie_REFCLK;
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_PHY_CTRL_CMN_TEST_PDOWN(r32)           _BFGET_(r32, 0, 0)
    #define   SET32PCIE_PHY_CTRL_CMN_TEST_PDOWN(r32,v)         _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_PHY_CTRL_CMN_TEST_PDOWN(r16)           _BFGET_(r16, 0, 0)
    #define   SET16PCIE_PHY_CTRL_CMN_TEST_PDOWN(r16,v)         _BFSET_(r16, 0, 0,v)

    #define   GET32PCIE_PHY_CTRL_CMN_TEST_BURNIN(r32)          _BFGET_(r32, 1, 1)
    #define   SET32PCIE_PHY_CTRL_CMN_TEST_BURNIN(r32,v)        _BFSET_(r32, 1, 1,v)
    #define   GET16PCIE_PHY_CTRL_CMN_TEST_BURNIN(r16)          _BFGET_(r16, 1, 1)
    #define   SET16PCIE_PHY_CTRL_CMN_TEST_BURNIN(r16,v)        _BFSET_(r16, 1, 1,v)

    #define   GET32PCIE_PHY_CTRL_CMN_TEST_BYPASS(r32)          _BFGET_(r32, 2, 2)
    #define   SET32PCIE_PHY_CTRL_CMN_TEST_BYPASS(r32,v)        _BFSET_(r32, 2, 2,v)
    #define   GET16PCIE_PHY_CTRL_CMN_TEST_BYPASS(r16)          _BFGET_(r16, 2, 2)
    #define   SET16PCIE_PHY_CTRL_CMN_TEST_BYPASS(r16,v)        _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_PHY_CTRL_CMN_REF_USE_PAD(r32)          _BFGET_(r32, 3, 3)
    #define   SET32PCIE_PHY_CTRL_CMN_REF_USE_PAD(r32,v)        _BFSET_(r32, 3, 3,v)
    #define   GET16PCIE_PHY_CTRL_CMN_REF_USE_PAD(r16)          _BFGET_(r16, 3, 3)
    #define   SET16PCIE_PHY_CTRL_CMN_REF_USE_PAD(r16,v)        _BFSET_(r16, 3, 3,v)

    #define   GET32PCIE_PHY_CTRL_CMN_REF_CLK_DIV2(r32)         _BFGET_(r32, 4, 4)
    #define   SET32PCIE_PHY_CTRL_CMN_REF_CLK_DIV2(r32,v)       _BFSET_(r32, 4, 4,v)
    #define   GET16PCIE_PHY_CTRL_CMN_REF_CLK_DIV2(r16)         _BFGET_(r16, 4, 4)
    #define   SET16PCIE_PHY_CTRL_CMN_REF_CLK_DIV2(r16,v)       _BFSET_(r16, 4, 4,v)

    #define   GET32PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT(r32)    _BFGET_(r32,11, 5)
    #define   SET32PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT(r32,v)  _BFSET_(r32,11, 5,v)
    #define   GET16PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT(r16)    _BFGET_(r16,11, 5)
    #define   SET16PCIE_PHY_CTRL_CMN_REF_CLK_MPLL_MULT(r16,v)  _BFSET_(r16,11, 5,v)

    #define   GET32PCIE_PHY_CTRL_CMN_RTUNE_REQ(r32)            _BFGET_(r32,12,12)
    #define   SET32PCIE_PHY_CTRL_CMN_RTUNE_REQ(r32,v)          _BFSET_(r32,12,12,v)
    #define   GET16PCIE_PHY_CTRL_CMN_RTUNE_REQ(r16)            _BFGET_(r16,12,12)
    #define   SET16PCIE_PHY_CTRL_CMN_RTUNE_REQ(r16,v)          _BFSET_(r16,12,12,v)

    #define   GET32PCIE_PHY_CTRL_CMN_ACJT_LEVEL(r32)           _BFGET_(r32,17,13)
    #define   SET32PCIE_PHY_CTRL_CMN_ACJT_LEVEL(r32,v)         _BFSET_(r32,17,13,v)

    #define   GET32PCIE_PHY_CTRL_CMN_PORT_SEL(r32)             _BFGET_(r32,19,18)
    #define   SET32PCIE_PHY_CTRL_CMN_PORT_SEL(r32,v)           _BFSET_(r32,19,18,v)
    #define   GET16PCIE_PHY_CTRL_CMN_PORT_SEL(r16)             _BFGET_(r16, 3, 2)
    #define   SET16PCIE_PHY_CTRL_CMN_PORT_SEL(r16,v)           _BFSET_(r16, 3, 2,v)

    #define   GET32PCIE_PHY_CTRL_CMN_VREG_BYPASS(r32)          _BFGET_(r32,20,20)
    #define   SET32PCIE_PHY_CTRL_CMN_VREG_BYPASS(r32,v)        _BFSET_(r32,20,20,v)
    #define   GET16PCIE_PHY_CTRL_CMN_VREG_BYPASS(r16)          _BFGET_(r16, 4, 4)
    #define   SET16PCIE_PHY_CTRL_CMN_VREG_BYPASS(r16,v)        _BFSET_(r16, 4, 4,v)

    #define   GET32PCIE_PHY_CTRL_CMN_COMMON_CLOCKS(r32)        _BFGET_(r32,21,21)
    #define   SET32PCIE_PHY_CTRL_CMN_COMMON_CLOCKS(r32,v)      _BFSET_(r32,21,21,v)
    #define   GET16PCIE_PHY_CTRL_CMN_COMMON_CLOCKS(r16)        _BFGET_(r16, 5, 5)
    #define   SET16PCIE_PHY_CTRL_CMN_COMMON_CLOCKS(r16,v)      _BFSET_(r16, 5, 5,v)

    #define   GET32PCIE_PHY_CTRL_CMN_RX_EI_DISABLE(r32)        _BFGET_(r32,22,22)
    #define   SET32PCIE_PHY_CTRL_CMN_RX_EI_DISABLE(r32,v)      _BFSET_(r32,22,22,v)
    #define   GET16PCIE_PHY_CTRL_CMN_RX_EI_DISABLE(r16)        _BFGET_(r16, 6, 6)
    #define   SET16PCIE_PHY_CTRL_CMN_RX_EI_DISABLE(r16,v)      _BFSET_(r16, 6, 6,v)

    #define   GET32PCIE_PHY_CTRL_CMN_TX_CM_DISABLE(r32)        _BFGET_(r32,23,23)
    #define   SET32PCIE_PHY_CTRL_CMN_TX_CM_DISABLE(r32,v)      _BFSET_(r32,23,23,v)
    #define   GET16PCIE_PHY_CTRL_CMN_TX_CM_DISABLE(r16)        _BFGET_(r16, 7, 7)
    #define   SET16PCIE_PHY_CTRL_CMN_TX_CM_DISABLE(r16,v)      _BFSET_(r16, 7, 7,v)

    #define   GET32PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK(r32)         _BFGET_(r32,24,24)
    #define   SET32PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK(r32,v)       _BFSET_(r32,24,24,v)
    #define   GET16PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK(r16)         _BFGET_(r16, 8, 8)
    #define   SET16PCIE_PHY_CTRL_CMN_TX2RX_LOOPBK(r16,v)       _BFSET_(r16, 8, 8,v)

    #define     w32PCIE_PHY_CTRL_CMN                           {\
            UNSG32 uPHY_CTRL_CMN_TEST_PDOWN                    :  1;\
            UNSG32 uPHY_CTRL_CMN_TEST_BURNIN                   :  1;\
            UNSG32 uPHY_CTRL_CMN_TEST_BYPASS                   :  1;\
            UNSG32 uPHY_CTRL_CMN_REF_USE_PAD                   :  1;\
            UNSG32 uPHY_CTRL_CMN_REF_CLK_DIV2                  :  1;\
            UNSG32 uPHY_CTRL_CMN_REF_CLK_MPLL_MULT             :  7;\
            UNSG32 uPHY_CTRL_CMN_RTUNE_REQ                     :  1;\
            UNSG32 uPHY_CTRL_CMN_ACJT_LEVEL                    :  5;\
            UNSG32 uPHY_CTRL_CMN_PORT_SEL                      :  2;\
            UNSG32 uPHY_CTRL_CMN_VREG_BYPASS                   :  1;\
            UNSG32 uPHY_CTRL_CMN_COMMON_CLOCKS                 :  1;\
            UNSG32 uPHY_CTRL_CMN_RX_EI_DISABLE                 :  1;\
            UNSG32 uPHY_CTRL_CMN_TX_CM_DISABLE                 :  1;\
            UNSG32 uPHY_CTRL_CMN_TX2RX_LOOPBK                  :  1;\
            UNSG32 RSVDxA038_b25                               :  7;\
          }
    union { UNSG32 u32PCIE_PHY_CTRL_CMN;
            struct w32PCIE_PHY_CTRL_CMN;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_PHY_CTRL0_PHY_LOS_BIAS(r32)            _BFGET_(r32, 2, 0)
    #define   SET32PCIE_PHY_CTRL0_PHY_LOS_BIAS(r32,v)          _BFSET_(r32, 2, 0,v)
    #define   GET16PCIE_PHY_CTRL0_PHY_LOS_BIAS(r16)            _BFGET_(r16, 2, 0)
    #define   SET16PCIE_PHY_CTRL0_PHY_LOS_BIAS(r16,v)          _BFSET_(r16, 2, 0,v)

    #define   GET32PCIE_PHY_CTRL0_PHY_LOS_LEVEL(r32)           _BFGET_(r32, 7, 3)
    #define   SET32PCIE_PHY_CTRL0_PHY_LOS_LEVEL(r32,v)         _BFSET_(r32, 7, 3,v)
    #define   GET16PCIE_PHY_CTRL0_PHY_LOS_LEVEL(r16)           _BFGET_(r16, 7, 3)
    #define   SET16PCIE_PHY_CTRL0_PHY_LOS_LEVEL(r16,v)         _BFSET_(r16, 7, 3,v)

    #define   GET32PCIE_PHY_CTRL0_RX0_EQ(r32)                  _BFGET_(r32,10, 8)
    #define   SET32PCIE_PHY_CTRL0_RX0_EQ(r32,v)                _BFSET_(r32,10, 8,v)
    #define   GET16PCIE_PHY_CTRL0_RX0_EQ(r16)                  _BFGET_(r16,10, 8)
    #define   SET16PCIE_PHY_CTRL0_RX0_EQ(r16,v)                _BFSET_(r16,10, 8,v)

    #define   GET32PCIE_PHY_CTRL0_RX1_EQ(r32)                  _BFGET_(r32,13,11)
    #define   SET32PCIE_PHY_CTRL0_RX1_EQ(r32,v)                _BFSET_(r32,13,11,v)
    #define   GET16PCIE_PHY_CTRL0_RX1_EQ(r16)                  _BFGET_(r16,13,11)
    #define   SET16PCIE_PHY_CTRL0_RX1_EQ(r16,v)                _BFSET_(r16,13,11,v)

    #define   GET32PCIE_PHY_CTRL0_TX_DEEMPH_GEN1(r32)          _BFGET_(r32,19,14)
    #define   SET32PCIE_PHY_CTRL0_TX_DEEMPH_GEN1(r32,v)        _BFSET_(r32,19,14,v)

    #define   GET32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5(r32)      _BFGET_(r32,25,20)
    #define   SET32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5(r32,v)    _BFSET_(r32,25,20,v)
    #define   GET16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5(r16)      _BFGET_(r16, 9, 4)
    #define   SET16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_3P5(r16,v)    _BFSET_(r16, 9, 4,v)

    #define   GET32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6(r32)        _BFGET_(r32,31,26)
    #define   SET32PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6(r32,v)      _BFSET_(r32,31,26,v)
    #define   GET16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6(r16)        _BFGET_(r16,15,10)
    #define   SET16PCIE_PHY_CTRL0_TX_DEEMPH_GEN2_6(r16,v)      _BFSET_(r16,15,10,v)

    #define     w32PCIE_PHY_CTRL0                              {\
            UNSG32 uPHY_CTRL0_PHY_LOS_BIAS                     :  3;\
            UNSG32 uPHY_CTRL0_PHY_LOS_LEVEL                    :  5;\
            UNSG32 uPHY_CTRL0_RX0_EQ                           :  3;\
            UNSG32 uPHY_CTRL0_RX1_EQ                           :  3;\
            UNSG32 uPHY_CTRL0_TX_DEEMPH_GEN1                   :  6;\
            UNSG32 uPHY_CTRL0_TX_DEEMPH_GEN2_3P5               :  6;\
            UNSG32 uPHY_CTRL0_TX_DEEMPH_GEN2_6                 :  6;\
          }
    union { UNSG32 u32PCIE_PHY_CTRL0;
            struct w32PCIE_PHY_CTRL0;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_PHY_CTRL1_TX_SWING_FULL(r32)           _BFGET_(r32, 6, 0)
    #define   SET32PCIE_PHY_CTRL1_TX_SWING_FULL(r32,v)         _BFSET_(r32, 6, 0,v)
    #define   GET16PCIE_PHY_CTRL1_TX_SWING_FULL(r16)           _BFGET_(r16, 6, 0)
    #define   SET16PCIE_PHY_CTRL1_TX_SWING_FULL(r16,v)         _BFSET_(r16, 6, 0,v)

    #define   GET32PCIE_PHY_CTRL1_TX_SWING_LOW(r32)            _BFGET_(r32,13, 7)
    #define   SET32PCIE_PHY_CTRL1_TX_SWING_LOW(r32,v)          _BFSET_(r32,13, 7,v)
    #define   GET16PCIE_PHY_CTRL1_TX_SWING_LOW(r16)            _BFGET_(r16,13, 7)
    #define   SET16PCIE_PHY_CTRL1_TX_SWING_LOW(r16,v)          _BFSET_(r16,13, 7,v)

    #define   GET32PCIE_PHY_CTRL1_TX0_TERM_OFFSET(r32)         _BFGET_(r32,18,14)
    #define   SET32PCIE_PHY_CTRL1_TX0_TERM_OFFSET(r32,v)       _BFSET_(r32,18,14,v)

    #define   GET32PCIE_PHY_CTRL1_TX1_TERM_OFFSET(r32)         _BFGET_(r32,23,19)
    #define   SET32PCIE_PHY_CTRL1_TX1_TERM_OFFSET(r32,v)       _BFSET_(r32,23,19,v)
    #define   GET16PCIE_PHY_CTRL1_TX1_TERM_OFFSET(r16)         _BFGET_(r16, 7, 3)
    #define   SET16PCIE_PHY_CTRL1_TX1_TERM_OFFSET(r16,v)       _BFSET_(r16, 7, 3,v)

    #define   GET32PCIE_PHY_CTRL1_TX_VBOOST_LVL(r32)           _BFGET_(r32,26,24)
    #define   SET32PCIE_PHY_CTRL1_TX_VBOOST_LVL(r32,v)         _BFSET_(r32,26,24,v)
    #define   GET16PCIE_PHY_CTRL1_TX_VBOOST_LVL(r16)           _BFGET_(r16,10, 8)
    #define   SET16PCIE_PHY_CTRL1_TX_VBOOST_LVL(r16,v)         _BFSET_(r16,10, 8,v)

    #define     w32PCIE_PHY_CTRL1                              {\
            UNSG32 uPHY_CTRL1_TX_SWING_FULL                    :  7;\
            UNSG32 uPHY_CTRL1_TX_SWING_LOW                     :  7;\
            UNSG32 uPHY_CTRL1_TX0_TERM_OFFSET                  :  5;\
            UNSG32 uPHY_CTRL1_TX1_TERM_OFFSET                  :  5;\
            UNSG32 uPHY_CTRL1_TX_VBOOST_LVL                    :  3;\
            UNSG32 RSVDxA040_b27                               :  5;\
          }
    union { UNSG32 u32PCIE_PHY_CTRL1;
            struct w32PCIE_PHY_CTRL1;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_PHY_STS0_RTUNE_ACK(r32)                _BFGET_(r32, 0, 0)
    #define   SET32PCIE_PHY_STS0_RTUNE_ACK(r32,v)              _BFSET_(r32, 0, 0,v)
    #define   GET16PCIE_PHY_STS0_RTUNE_ACK(r16)                _BFGET_(r16, 0, 0)
    #define   SET16PCIE_PHY_STS0_RTUNE_ACK(r16,v)              _BFSET_(r16, 0, 0,v)

    #define     w32PCIE_PHY_STS0                               {\
            UNSG32 uPHY_STS0_RTUNE_ACK                         :  1;\
            UNSG32 RSVDxA044_b1                                : 31;\
          }
    union { UNSG32 u32PCIE_PHY_STS0;
            struct w32PCIE_PHY_STS0;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_HWDBG_CTRL_PCIESEL(r32)                _BFGET_(r32, 1, 0)
    #define   SET32PCIE_HWDBG_CTRL_PCIESEL(r32,v)              _BFSET_(r32, 1, 0,v)
    #define   GET16PCIE_HWDBG_CTRL_PCIESEL(r16)                _BFGET_(r16, 1, 0)
    #define   SET16PCIE_HWDBG_CTRL_PCIESEL(r16,v)              _BFSET_(r16, 1, 0,v)

    #define   GET32PCIE_HWDBG_CTRL_DATASEL(r32)                _BFGET_(r32, 2, 2)
    #define   SET32PCIE_HWDBG_CTRL_DATASEL(r32,v)              _BFSET_(r32, 2, 2,v)
    #define   GET16PCIE_HWDBG_CTRL_DATASEL(r16)                _BFGET_(r16, 2, 2)
    #define   SET16PCIE_HWDBG_CTRL_DATASEL(r16,v)              _BFSET_(r16, 2, 2,v)

    #define   GET32PCIE_HWDBG_CTRL_SIGSEL(r32)                 _BFGET_(r32,10, 3)
    #define   SET32PCIE_HWDBG_CTRL_SIGSEL(r32,v)               _BFSET_(r32,10, 3,v)
    #define   GET16PCIE_HWDBG_CTRL_SIGSEL(r16)                 _BFGET_(r16,10, 3)
    #define   SET16PCIE_HWDBG_CTRL_SIGSEL(r16,v)               _BFSET_(r16,10, 3,v)

    #define     w32PCIE_HWDBG_CTRL                             {\
            UNSG32 uHWDBG_CTRL_PCIESEL                         :  2;\
            UNSG32 uHWDBG_CTRL_DATASEL                         :  1;\
            UNSG32 uHWDBG_CTRL_SIGSEL                          :  8;\
            UNSG32 RSVDxA048_b11                               : 21;\
          }
    union { UNSG32 u32PCIE_HWDBG_CTRL;
            struct w32PCIE_HWDBG_CTRL;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_HWDBG_DATA_VAL(r32)                    _BFGET_(r32,31, 0)
    #define   SET32PCIE_HWDBG_DATA_VAL(r32,v)                  _BFSET_(r32,31, 0,v)

    #define     w32PCIE_HWDBG_DATA                             {\
            UNSG32 uHWDBG_DATA_VAL                             : 32;\
          }
    union { UNSG32 u32PCIE_HWDBG_DATA;
            struct w32PCIE_HWDBG_DATA;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER(r32) _BFGET_(r32,31, 0)
    #define   SET32PCIE_AXI_LIMIT_LOWER_ADDR_FILTER_LOWER(r32,v) _BFSET_(r32,31, 0,v)

    #define     w32PCIE_AXI_LIMIT_LOWER                        {\
            UNSG32 uAXI_LIMIT_LOWER_ADDR_FILTER_LOWER          : 32;\
          }
    union { UNSG32 u32PCIE_AXI_LIMIT_LOWER;
            struct w32PCIE_AXI_LIMIT_LOWER;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER(r32) _BFGET_(r32,31, 0)
    #define   SET32PCIE_AXI_LIMIT_UPPER_ADDR_FILTER_UPPER(r32,v) _BFSET_(r32,31, 0,v)

    #define     w32PCIE_AXI_LIMIT_UPPER                        {\
            UNSG32 uAXI_LIMIT_UPPER_ADDR_FILTER_UPPER          : 32;\
          }
    union { UNSG32 u32PCIE_AXI_LIMIT_UPPER;
            struct w32PCIE_AXI_LIMIT_UPPER;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_SPARE_0_REGBITS(r32)                   _BFGET_(r32,31, 0)
    #define   SET32PCIE_SPARE_0_REGBITS(r32,v)                 _BFSET_(r32,31, 0,v)

    #define     w32PCIE_SPARE_0                                {\
            UNSG32 uSPARE_0_REGBITS                            : 32;\
          }
    union { UNSG32 u32PCIE_SPARE_0;
            struct w32PCIE_SPARE_0;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_SPARE_1_REGBITS(r32)                   _BFGET_(r32,31, 0)
    #define   SET32PCIE_SPARE_1_REGBITS(r32,v)                 _BFSET_(r32,31, 0,v)

    #define     w32PCIE_SPARE_1                                {\
            UNSG32 uSPARE_1_REGBITS                            : 32;\
          }
    union { UNSG32 u32PCIE_SPARE_1;
            struct w32PCIE_SPARE_1;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_SPARE_2_REGBITS(r32)                   _BFGET_(r32,31, 0)
    #define   SET32PCIE_SPARE_2_REGBITS(r32,v)                 _BFSET_(r32,31, 0,v)

    #define     w32PCIE_SPARE_2                                {\
            UNSG32 uSPARE_2_REGBITS                            : 32;\
          }
    union { UNSG32 u32PCIE_SPARE_2;
            struct w32PCIE_SPARE_2;
          };
    ///////////////////////////////////////////////////////////
    #define   GET32PCIE_SPARE_3_REGBITS(r32)                   _BFGET_(r32,31, 0)
    #define   SET32PCIE_SPARE_3_REGBITS(r32,v)                 _BFSET_(r32,31, 0,v)

    #define     w32PCIE_SPARE_3                                {\
            UNSG32 uSPARE_3_REGBITS                            : 32;\
          }
    union { UNSG32 u32PCIE_SPARE_3;
            struct w32PCIE_SPARE_3;
          };
    ///////////////////////////////////////////////////////////
             UNSG8 RSVDxA068                                   [24472];
    ///////////////////////////////////////////////////////////
    } SIE_PCIE;

    typedef union  T32PCIE_MSI_INTR_RX
          { UNSG32 u32;
            struct w32PCIE_MSI_INTR_RX;
                 } T32PCIE_MSI_INTR_RX;
    typedef union  T32PCIE_MSI_INTR_STATUS
          { UNSG32 u32;
            struct w32PCIE_MSI_INTR_STATUS;
                 } T32PCIE_MSI_INTR_STATUS;
    typedef union  T32PCIE_MSI_INTR_MASK
          { UNSG32 u32;
            struct w32PCIE_MSI_INTR_MASK;
                 } T32PCIE_MSI_INTR_MASK;
    typedef union  T32PCIE_MAC_INTR_STATUS
          { UNSG32 u32;
            struct w32PCIE_MAC_INTR_STATUS;
                 } T32PCIE_MAC_INTR_STATUS;
    typedef union  T32PCIE_MAC_INTR_MASK
          { UNSG32 u32;
            struct w32PCIE_MAC_INTR_MASK;
                 } T32PCIE_MAC_INTR_MASK;
    typedef union  T32PCIE_MAC_INTR_STATUS1
          { UNSG32 u32;
            struct w32PCIE_MAC_INTR_STATUS1;
                 } T32PCIE_MAC_INTR_STATUS1;
    typedef union  T32PCIE_MAC_INTR_MASK1
          { UNSG32 u32;
            struct w32PCIE_MAC_INTR_MASK1;
                 } T32PCIE_MAC_INTR_MASK1;
    typedef union  T32PCIE_MAC_CTRL
          { UNSG32 u32;
            struct w32PCIE_MAC_CTRL;
                 } T32PCIE_MAC_CTRL;
    typedef union  T32PCIE_MAC_STATUS
          { UNSG32 u32;
            struct w32PCIE_MAC_STATUS;
                 } T32PCIE_MAC_STATUS;
    typedef union  T32PCIE_MAC_RID_REG
          { UNSG32 u32;
            struct w32PCIE_MAC_RID_REG;
                 } T32PCIE_MAC_RID_REG;
    typedef union  T32PCIE_MAC_CLK_CTRL
          { UNSG32 u32;
            struct w32PCIE_MAC_CLK_CTRL;
                 } T32PCIE_MAC_CLK_CTRL;
    typedef union  T32PCIE_PHY_CTRL_CMN
          { UNSG32 u32;
            struct w32PCIE_PHY_CTRL_CMN;
                 } T32PCIE_PHY_CTRL_CMN;
    typedef union  T32PCIE_PHY_CTRL0
          { UNSG32 u32;
            struct w32PCIE_PHY_CTRL0;
                 } T32PCIE_PHY_CTRL0;
    typedef union  T32PCIE_PHY_CTRL1
          { UNSG32 u32;
            struct w32PCIE_PHY_CTRL1;
                 } T32PCIE_PHY_CTRL1;
    typedef union  T32PCIE_PHY_STS0
          { UNSG32 u32;
            struct w32PCIE_PHY_STS0;
                 } T32PCIE_PHY_STS0;
    typedef union  T32PCIE_HWDBG_CTRL
          { UNSG32 u32;
            struct w32PCIE_HWDBG_CTRL;
                 } T32PCIE_HWDBG_CTRL;
    typedef union  T32PCIE_HWDBG_DATA
          { UNSG32 u32;
            struct w32PCIE_HWDBG_DATA;
                 } T32PCIE_HWDBG_DATA;
    typedef union  T32PCIE_AXI_LIMIT_LOWER
          { UNSG32 u32;
            struct w32PCIE_AXI_LIMIT_LOWER;
                 } T32PCIE_AXI_LIMIT_LOWER;
    typedef union  T32PCIE_AXI_LIMIT_UPPER
          { UNSG32 u32;
            struct w32PCIE_AXI_LIMIT_UPPER;
                 } T32PCIE_AXI_LIMIT_UPPER;
    typedef union  T32PCIE_SPARE_0
          { UNSG32 u32;
            struct w32PCIE_SPARE_0;
                 } T32PCIE_SPARE_0;
    typedef union  T32PCIE_SPARE_1
          { UNSG32 u32;
            struct w32PCIE_SPARE_1;
                 } T32PCIE_SPARE_1;
    typedef union  T32PCIE_SPARE_2
          { UNSG32 u32;
            struct w32PCIE_SPARE_2;
                 } T32PCIE_SPARE_2;
    typedef union  T32PCIE_SPARE_3
          { UNSG32 u32;
            struct w32PCIE_SPARE_3;
                 } T32PCIE_SPARE_3;
    ///////////////////////////////////////////////////////////

    typedef union  TPCIE_MSI_INTR_RX
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MSI_INTR_RX;
                   };
                 } TPCIE_MSI_INTR_RX;
    typedef union  TPCIE_MSI_INTR_STATUS
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MSI_INTR_STATUS;
                   };
                 } TPCIE_MSI_INTR_STATUS;
    typedef union  TPCIE_MSI_INTR_MASK
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MSI_INTR_MASK;
                   };
                 } TPCIE_MSI_INTR_MASK;
    typedef union  TPCIE_MAC_INTR_STATUS
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_INTR_STATUS;
                   };
                 } TPCIE_MAC_INTR_STATUS;
    typedef union  TPCIE_MAC_INTR_MASK
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_INTR_MASK;
                   };
                 } TPCIE_MAC_INTR_MASK;
    typedef union  TPCIE_MAC_INTR_STATUS1
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_INTR_STATUS1;
                   };
                 } TPCIE_MAC_INTR_STATUS1;
    typedef union  TPCIE_MAC_INTR_MASK1
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_INTR_MASK1;
                   };
                 } TPCIE_MAC_INTR_MASK1;
    typedef union  TPCIE_MAC_CTRL
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_CTRL;
                   };
                 } TPCIE_MAC_CTRL;
    typedef union  TPCIE_MAC_STATUS
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_STATUS;
                   };
                 } TPCIE_MAC_STATUS;
    typedef union  TPCIE_MAC_RID_REG
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_RID_REG;
                   };
                 } TPCIE_MAC_RID_REG;
    typedef union  TPCIE_MAC_CLK_CTRL
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_MAC_CLK_CTRL;
                   };
                 } TPCIE_MAC_CLK_CTRL;
    typedef union  TPCIE_PHY_CTRL_CMN
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_PHY_CTRL_CMN;
                   };
                 } TPCIE_PHY_CTRL_CMN;
    typedef union  TPCIE_PHY_CTRL0
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_PHY_CTRL0;
                   };
                 } TPCIE_PHY_CTRL0;
    typedef union  TPCIE_PHY_CTRL1
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_PHY_CTRL1;
                   };
                 } TPCIE_PHY_CTRL1;
    typedef union  TPCIE_PHY_STS0
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_PHY_STS0;
                   };
                 } TPCIE_PHY_STS0;
    typedef union  TPCIE_HWDBG_CTRL
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_HWDBG_CTRL;
                   };
                 } TPCIE_HWDBG_CTRL;
    typedef union  TPCIE_HWDBG_DATA
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_HWDBG_DATA;
                   };
                 } TPCIE_HWDBG_DATA;
    typedef union  TPCIE_AXI_LIMIT_LOWER
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_AXI_LIMIT_LOWER;
                   };
                 } TPCIE_AXI_LIMIT_LOWER;
    typedef union  TPCIE_AXI_LIMIT_UPPER
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_AXI_LIMIT_UPPER;
                   };
                 } TPCIE_AXI_LIMIT_UPPER;
    typedef union  TPCIE_SPARE_0
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_SPARE_0;
                   };
                 } TPCIE_SPARE_0;
    typedef union  TPCIE_SPARE_1
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_SPARE_1;
                   };
                 } TPCIE_SPARE_1;
    typedef union  TPCIE_SPARE_2
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_SPARE_2;
                   };
                 } TPCIE_SPARE_2;
    typedef union  TPCIE_SPARE_3
          { UNSG32 u32[1];
            struct {
            struct w32PCIE_SPARE_3;
                   };
                 } TPCIE_SPARE_3;

    ///////////////////////////////////////////////////////////
     SIGN32 PCIE_drvrd(SIE_PCIE *p, UNSG32 base, SIGN32 mem, SIGN32 tst);
     SIGN32 PCIE_drvwr(SIE_PCIE *p, UNSG32 base, SIGN32 mem, SIGN32 tst, UNSG32 *pcmd);
       void PCIE_reset(SIE_PCIE *p);
     SIGN32 PCIE_cmp  (SIE_PCIE *p, SIE_PCIE *pie, char *pfx, void *hLOG, SIGN32 mem, SIGN32 tst);
    #define PCIE_check(p,pie,pfx,hLOG) PCIE_cmp(p,pie,pfx,(void*)(hLOG),0,0)
    #define PCIE_print(p,    pfx,hLOG) PCIE_cmp(p,0,  pfx,(void*)(hLOG),0,0)

#endif
//////
/// ENDOFINTERFACE: PCIE
////////////////////////////////////////////////////////////



#ifdef __cplusplus
  }
#endif
#pragma  pack()

#endif
//////
/// ENDOFFILE: pcie.h
////////////////////////////////////////////////////////////

